<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iaksh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hello world!">
<meta property="og:url" content="https://iaksh.github.io/index.html">
<meta property="og:site_name" content="Hello world!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IAKSH">
<meta property="article:tag" content="IAKSH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://iaksh.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hello world!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello world!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/11/07/%E4%BD%BF%E7%94%A8STM32CubeMX-Visual-Studio-Code-OpenOCD-PlatformIO%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%8E%B0%E4%BB%A3%E5%8C%96%E4%B8%94%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/%E4%BD%BF%E7%94%A8STM32CubeMX-Visual-Studio-Code-OpenOCD-PlatformIO%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%8E%B0%E4%BB%A3%E5%8C%96%E4%B8%94%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%9A%84STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">使用STM32CubeMX + Visual Studio Code + OpenOCD + PlatformIO搭建一个现代化且跨平台的STM32开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-07 23:20:39" itemprop="dateCreated datePublished" datetime="2022-11-07T23:20:39+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:20:37" itemprop="dateModified" datetime="2022-11-14T10:20:37+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://img-blog.csdnimg.cn/img_convert/db2f8508b9dab7cea7286fd0411dda93.png" alt="xv7Ml9.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实这套工具链（除开STM32CubeMX）不仅STM32能用，还能给8051，ESP32，Arduino等芯片使用，只要你所使用的烧录工具以及芯片本身被PlatformIO支持。</p>
<p>在本文介绍的这套工具链中，Visual Studio Code为文本编辑器，gcc-arm-none-eabi为编译器，STM32CubeMX用于创建基础代码，而PlatformIO则将上述内容组合到一起，形成了一个强大的IDE。</p>
<h1 id="为什么要抛弃Keli与MDK"><a href="#为什么要抛弃Keli与MDK" class="headerlink" title="为什么要抛弃Keli与MDK"></a>为什么要抛弃Keli与MDK</h1><p>抛弃这些老旧的IDE的理由很多，对于初学者而言，这些IDE通常没有如代码补全之类的现代IDE的基本功能，UI也异常老土；对于大多团队，MDK等老旧IDE通常仅有Windows版本，就大多数情况而言，统一开发平台往往比较困难，甚至有部分团队因为各种各样的原因不得不在Linux平台上进行开发；而对于嵌入式领域从业者而言，该类IDE通常为专有软件，使用其进行嵌入式开发，必须遵守相关的协议，具体内容包括但不限于软件付费，编译器限制代码行数等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/83b0422ef74a0cb7e62a2f4774d77fea.png" alt="xv7dld.png"></p>
<p>其次，STM32CubeMX以及HAL库的出现向老旧的生产方式发起了挑战，使用STM32CubeMX以及HAL库，我们可以很轻松地生成STM32 MCU的初始化代码以及工程，而不需要深入了解ARM架构中海量的寄存器以及芯片内部各种晦涩难懂的电路。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/999399754b04212efd16c54af1b4142d.png" alt="xvHaNT.png"></p>
<p>尽管这种不需深入理解硬件便直接“浮沙筑高台”的开发方式以及HAL库本身的代码质量一直饱受诟病，但不得不承认，此乃大势所趋。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/84e931afd6eb33c45a73a57304159111.png" alt="xvbXe1.png"></p>
<p>但是STM32CubeMX只是一个项目生成工具，HAL也仅仅只是一个代码库，我们还需要一个代码编辑器。</p>
<p>Visual Studio Code是微软牵头的一个半开源软件（其开源项目名为vscodium，Visual Studio Code是微软构建的发行版，两者关系类似于AOSP和Android），该软件基于Electron框架构建，定位为代码编辑器，但得益于其强大的扩展能力以及社区生态（当然还有微软的钱），打满插件的Visual Studio Code可以摇身一变，<del>成为21世纪最好用的IDE。</del></p>
<p>但其实，对于我们的需求，只需要打一个PlatformIO IDE插件就足够了。</p>
<p>PlatformIO是一个开源项目，其的本体是一个Python脚本，它是一个集成工具，提供了对各种嵌入式平台的一键部署和调试，以及代码补全功能。PlatformIO的开发者为该项目编写了相应的Visual Studio Code插件，以使该套系统能集成在Visual Studio Code上，形成一个强大的嵌入式IDE。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/828d3aadacde9c23eae2b2344a0b8d75.png" alt="xvqRpD.png"></p>
<h1 id="工具链介绍"><a href="#工具链介绍" class="headerlink" title="工具链介绍"></a>工具链介绍</h1><h2 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h2><blockquote>
<p>STM32CubeMX是一种图形工具，通过分步过程可以非常轻松地配置STM32微控制器和微处理器，以及为Arm® Cortex®-M内核或面向Arm® Cortex®-A内核的特定Linux®设备树生成相应的初始化C代码。</p>
</blockquote>
<p>这是STM32的东家ST公司开发并推出的一款用于配置STM32工程的图形化软件，基于Java构建，提供了对于初始化代码，GPIO，分频，调试，甚至是实时操作系统的一键部署以及图形化配置功能，极大简化了基于ARM架构的STM32芯片原本复杂的配置过程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/59ec9fb9160cde4f719539f149e1eb60.png" alt="xvqHtf.png"></p>
<p>在我们的工具链中，STM32CubeMX主要负责生成基础的，让硬件至少能运行的代码。</p>
<h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>VSCode是微软推出的一款半开源的代码编辑器，基于Javascript的Electron框架构建，拥有庞大的社区生态以及无与伦比的可扩展性，通过第三方插件，Visual Studio Code能被轻易配置为多种语言的<strong>类</strong>IDE环境，甚至有部分新兴编程语言直接将VSCode指定为官方开发工具。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/44a16f560c02c9c76a5f6d8d78fd8819.png" alt="xvqjXj.png"></p>
<p>在我们的工具链中，VSCode主要作为代码编辑器，以及整套系统的框架。</p>
<h2 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h2><p>OpenOCD（Open On-Chip Debugger），即开源片上调试器，是一个命令行工具，一个诞生于2005年的嵌入式设备调试，编程工具。OpenOCD需要一个仿真器（一个通常使用USB接口的硬件设备，是能够提供调试目标的电信号的小型硬件单元）才能运作，这个仿真器可以是JLink，也可以是STLink，只要开发板兼容相应的协议。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0ae6a1907d03025529fabdee537e1e1a.png" alt="xvL9A0.png"></p>
<p>在我们的工具链中，OpenOCD负责与仿真器合作建立其从主机到开发板的连接，在此基础上进行程序烧录和调试。</p>
<h2 id="gcc-arm-none-eabi"><a href="#gcc-arm-none-eabi" class="headerlink" title="gcc-arm-none-eabi"></a>gcc-arm-none-eabi</h2><p>gcc-arm-none-eabi是GNU项目的GCC项目的一部分。（此处GCC指GNU‘s Compiler Collection，GNU项目的编译器集），是一个交叉编译器，用于在Windows，Linux等平台上为ARM架构的嵌入式环境编译软件。</p>
<p>在我们的工具链中，gcc-arm-none-eabi作为编译器。</p>
<p>实际上，你不需要自行下载以及配置它，该过程会由PlatformIO自动完成。</p>
<h2 id="PlatformIO-IDE插件"><a href="#PlatformIO-IDE插件" class="headerlink" title="PlatformIO IDE插件"></a>PlatformIO IDE插件</h2><p>PlatformIO IDE插件是Platform项目的组成部分之一，是VSCode的一款插件，提供了嵌入式工程的一键式环境部署以及编译，调试功能。PlaformIO就像是一瓶胶水，将原本零零散散的各个模块粘连形成了一个整体。</p>
<p>在我们的工具链中，PlatformIO插件为VSCode补充了功能，使其变成一个强大的跨平台嵌入式IDE。</p>
<h2 id="STLink（仿真器硬件）"><a href="#STLink（仿真器硬件）" class="headerlink" title="STLink（仿真器硬件）"></a>STLink（仿真器硬件）</h2><p>STLink是由ST公司推出的一款在线调试编程器，支持JTAG和SWD协议，以及用于STM8系列MCU的SWIM协议。几乎是国内嵌入式工程师人手一个的必备品。</p>
<p>实际上，你也可以使用其他的仿真器，比如JLink，只要开发板和OpenOCD都兼容其协议。</p>
<p>在我们的工具链中，仿真器负责辅助OpenOCD运作，建立从主机到开发板的通信。</p>
<h1 id="配置流程（Windows）"><a href="#配置流程（Windows）" class="headerlink" title="配置流程（Windows）"></a>配置流程（Windows）</h1><h2 id="下载并安装软件"><a href="#下载并安装软件" class="headerlink" title="下载并安装软件"></a>下载并安装软件</h2><ol>
<li><p>STM32CubeMX</p>
<p>ST公司的官网提供了该软件的下载页面：<a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/stm32cubemx.html#get-software">STM32CubeMX - STM32Cube初始化代码生成器 - STMicroelectronics</a></p>
<p>不过你需要注册一个账号才能下载，建议使用临时邮箱，因为ST会朝你的邮箱里不断地赛广告。</p>
</li>
<li><p>Visual Studio Code</p>
<p>微软的官网提供了该软件的下载页面：<a target="_blank" rel="noopener" href="https://code.visualstudio.com/Download">Download Visual Studio Code - Mac, Linux, Windows</a></p>
</li>
<li><p>Python</p>
<p>由于PlatformIO IDE插件基于Python构建，你需要安装一个Python以运行PlatformIO。</p>
<p>Python官网的下载页：<a target="_blank" rel="noopener" href="https://www.python.org/downloads/">Download Python | Python.org</a></p>
<p>或者，如果你的C盘足够大，可以在微软商店里搜索并安装Python。</p>
</li>
<li><p>OpenOCD</p>
<p>OpenOCD在Github上有一个镜像仓库，这是它的Release页：<a target="_blank" rel="noopener" href="https://github.com/openocd-org/openocd/releases/">Releases · openocd-org/openocd (github.com)</a></p>
<p>此处提供了基于mingw32构建的Windows版本（32位），解压后需配置环境变量（path项）。</p>
</li>
</ol>
<h2 id="为VSCode安装PlatformIO-IDE插件"><a href="#为VSCode安装PlatformIO-IDE插件" class="headerlink" title="为VSCode安装PlatformIO IDE插件"></a>为VSCode安装PlatformIO IDE插件</h2><p>直接在VSCode的插件商店中搜索PlatformIO IDE即可，图标为一个蚂蚁头。</p>
<h1 id="配置流程（Linux）"><a href="#配置流程（Linux）" class="headerlink" title="配置流程（Linux）"></a>配置流程（Linux）</h1><p>你都会用Linux了，这些还要我教你？😓</p>
<h1 id="第一个工程"><a href="#第一个工程" class="headerlink" title="第一个工程"></a>第一个工程</h1><h2 id="从STM32CubeMX创建工程"><a href="#从STM32CubeMX创建工程" class="headerlink" title="从STM32CubeMX创建工程"></a>从STM32CubeMX创建工程</h2><p>STM32CubeMX可以直接选择MCU以创建对应工程，在主页选择<code>ACCESS TO MCU SELECTOR</code>即可，期间需要下载部分索引库以及你所选择的MCU相应的库和配置文件，请注意检查你的网络和磁盘状况。</p>
<p>期间会有这样一个页面让你定义需要用到的GPIO，以及MCU的调试方式，根据项目需要进行设定即可。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/999399754b04212efd16c54af1b4142d.png" alt="图-配置GPIO"></p>
<p>配置完GPIO后在<code>Project Manager</code>选项卡中输入项目名称以及储存路径即可，本文配置中使用的Toolchain为STM32CubeIDE，请确保该页中<code>Toolchain / IDE</code>项为<code>STM32CubeIDE</code>。你也可以自行摸索Makefile等构建方式在这套工具链中的使用。</p>
<h2 id="在VSCode中使用PlatformIO-IDE插件打开工程"><a href="#在VSCode中使用PlatformIO-IDE插件打开工程" class="headerlink" title="在VSCode中使用PlatformIO IDE插件打开工程"></a>在VSCode中使用PlatformIO IDE插件打开工程</h2><p>在VSCode中弹出的<code>PIO Home</code>页面里选择<code>New Project</code>以创建一个PlatformIO工程，路径和项目名应与之前在STM32CubeMX中创建的工程一致，以保证PlatformIO工程能够使用STM32CubeMX生成的库和配置文件。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ef2a15f3a410d596bb6cc57953033620.png" alt="xvLYDA.png"></p>
<p>选择与你的开发板对应的MCU即可。</p>
<p>另外，由于一些不可抗力，PlatformIO至今未能在国内搭建资源镜像站，在创建PlatformIO工程的过程中需要从境外服务器下载相应的配置文件，通常该过程会异常缓慢或者根本无法下载，请使用科学上网或手机热点以缓解此类问题。</p>
<h1 id="修改PlatformIO-IDE配置"><a href="#修改PlatformIO-IDE配置" class="headerlink" title="修改PlatformIO IDE配置"></a>修改PlatformIO IDE配置</h1><p>其配置文件名为<code>platformio.ini</code>，你可以在创建的项目的根目录找到该文件。</p>
<p>我们需要修改的主要是其上传，调试工具链以及源代码，头文件的路径</p>
<p>你可以参照下面的文件进行修改，这是我使用搭载STM32F407VET6的开发板与STLink仿真器进行开发的配置文件。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; PlatformIO Project Configuration File</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">;   Build options: build flags, source filter</span></span><br><span class="line"><span class="comment">;   Upload options: custom upload port, speed and extra flags</span></span><br><span class="line"><span class="comment">;   Library options: dependencies, extra library storages</span></span><br><span class="line"><span class="comment">;   Advanced options: extra scripting</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">; Please visit documentation for the other options and examples</span></span><br><span class="line"><span class="comment">; https://docs.platformio.org/page/projectconf.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[env:black_f407ve]</span></span><br><span class="line"><span class="attr">platform</span> = ststm32</span><br><span class="line"><span class="attr">board</span> = black_f407ve</span><br><span class="line"><span class="attr">framework</span> = stm32cube</span><br><span class="line"><span class="comment">; 你需要指定debug_tool，然后才能Debug</span></span><br><span class="line"><span class="attr">upload_protocol</span> = stlink</span><br><span class="line"><span class="attr">debug_tool</span> = stlink</span><br><span class="line"></span><br><span class="line"><span class="section">[platformio]</span></span><br><span class="line"><span class="attr">include_dir</span>=Inc</span><br><span class="line"><span class="attr">src_dir</span>=src</span><br></pre></td></tr></table></figure>
<p>配置好上述的<code>upload_protocol</code>,<code>debug_tool</code>,以<code>include_dir</code>，<code>src_dir</code>后，PlatformIO IDE的一键编译，烧录，调试，还有代码补全，语法提示功能全部正常运行。</p>
<h2 id="编写一个闪烁的LED"><a href="#编写一个闪烁的LED" class="headerlink" title="编写一个闪烁的LED"></a>编写一个闪烁的LED</h2><p>平平无奇的嵌入式版hello world</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* USER CODE END WHILE */</span></span><br><span class="line">    HAL_GPIO_TogglePin(LED_VCC_GPIO_Port,LED_VCC_Pin);</span><br><span class="line">    HAL_Delay(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">/* USER CODE BEGIN 3 */</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h2 id="烧录和运行程序"><a href="#烧录和运行程序" class="headerlink" title="烧录和运行程序"></a>烧录和运行程序</h2><p>PlatformIO IDE插件贴心地为你在VSCode底部创建了几个按钮</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01d1d8dc9dc287607e28b68332cef4b9.png" alt="xvLPhT.png"></p>
<p>点击其中右方向键即可一键编译，烧录，执行。</p>
<h1 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h1><p>PlatformIO IDE插件已经为你准备好了一切，只需要按下F5就能编译，烧录，开始调试。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/55661c69410b024c045e64dadb295453.png" alt="xvL0C8.png"></p>
<p>PlatformIO IDE插件将堆栈调用等数据全部显示在了VSCode的Debug页里，一切就像在使用Visual Studio那样舒适。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/11/03/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/03/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">快速入门正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-03 00:26:08" itemprop="dateCreated datePublished" datetime="2022-11-03T00:26:08+08:00">2022-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:18:30" itemprop="dateModified" datetime="2022-11-14T10:18:30+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 | 前言"></a>0x00 | 前言</h1><p>本文简单介绍了<code>PCRE2</code>正则表达式语法，然后简单介绍并提供了在<code>Python</code>与<code>C++</code>标准库中正则表达式的使用例。</p>
<h1 id="0x01-什么是正则表达式"><a href="#0x01-什么是正则表达式" class="headerlink" title="0x01 | 什么是正则表达式"></a>0x01 | 什么是正则表达式</h1><p>正则表达式（Regular Expression，可简写为<code>regex</code>或<code>re</code>），正则表达式一般使用单个字符串来描述、匹配一系列符合某个语法规则的字符串，通常被用来检索、替换那些符合某个模式（规则）的文本。</p>
<p>正则表达式通常用于从某一文本中提取特定的字符串，或者检验字符串的格式等。</p>
<p>需要注意的是，由于其实现原理，即便进行了预编译，正则表达式通常仍是<strong>缓慢的</strong>。</p>
<h1 id="0x02-正则表达式的语法"><a href="#0x02-正则表达式的语法" class="headerlink" title="0x02 | 正则表达式的语法"></a>0x02 | 正则表达式的语法</h1><ul>
<li><p>限定符</p>
<p>1.<code>？</code></p>
<p>  <code>a?</code>表示匹配过程中字符/字符串<code>a</code>可有可无，有则匹配。</p>
<ol>
<li><p><code>*</code></p>
<p><code>a*</code>表示字符/字符串<code>a</code>可有可无，有多个连续的字符/字符串a`则匹配。</p>
</li>
<li><p><code>+</code></p>
<p><code>a+</code>表示字符/字符串必须存在，匹配单独或连续出现的字符/字符串<code>a</code>。</p>
</li>
<li><p><code>&#123;...&#125;</code></p>
<p>是限定符<code>+</code>的增强版，<code>a&#123;n,m&#125;</code>表示匹配连续出现$(n,m)$次的字符/字符串<code>a</code>。</p>
<p>另外，你也可以单独指定其下限，例如<code>a&#123;n,&#125;</code>，表示匹配连续出现了至少<code>n</code>次的字符/字符串<code>a</code>。</p>
</li>
</ol>
</li>
<li><p>或运算</p>
<p>正则表达式中的或运算符为<code>|</code>，同时可以使用<code>(</code>与<code>)</code>为其限定范围。</p>
<p>另外，为了避免出错，我建议将所有或运算包在<code>(</code>与<code>)</code>之间。</p>
</li>
<li><p>字符类</p>
<p>字符类允许你匹配列出的字符所构成的所有字符/字符串。在实际使用中，其后往往需要跟随限定符，例如<code>[a-z]+</code>，表示匹配由<code>a</code>到<code>z</code>的所有小写字母中的任意几个组成的字符/字符串。</p>
<p>例如，下述四个字符类从上自下依次表示：</p>
<ol>
<li><p>由<code>a</code>，<code>b</code>，<code>c</code>三种字母中的任意几个组成的字符/字符串。</p>
</li>
<li><p>由<code>a</code>到<code>z</code>的<code>26</code>个小写字母中的任意几个组成的字符/字符串。</p>
</li>
<li><p>由所有大/小写字母和所有数组中的任意几个组成的字符/字符串。</p>
</li>
<li><p>不含有<code>a</code>到<code>y</code>的<code>25</code>个字母中的任何一个的字符/字符串。</p>
</li>
</ol>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[abc]</span><br><span class="line">[a-z]</span><br><span class="line">[a-zA-Z0-9]</span><br><span class="line">[^a-y]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>元字符</p>
<p>在实际应用中，我们所处理的字符/字符串类型往往纷繁复杂，为此，正则表达式为我们规定了一些元字符，用于直接表示某些常见但却难以用其他常规手段表示的字符/字符串。例如<strong>数字</strong>，<strong>单词开头</strong>，<strong>单词结尾</strong>。</p>
<p>类似占位符，正则表达式中的绝大部分元字符都以反斜杠<code>\</code>开头，其中部分内容如下，其中的`<str>代表字符/字符串。</p>
<p>| 元字符 | 释义  |<br>| —- | —- |<br>| \d  | 表示数字，等价于<code>[0-9]</code> |<br>| \w  | 表示单词，等价于<code>[a-zA-Z0-9_]</code> |<br>| \s  | 表示空白符，同时包含制表符和换行符 |<br>| \D  | 表示非数字字符 |<br>| \W  | 表示非单词字符 |<br>| .   | 表示除换行符外的任意字符 |<br>| ^<str> | 特殊元字符，表示匹配行首的<code>&lt;str&gt;</code> |<br>| <str>$ | 特殊元字符，表示匹配行尾的<code>&lt;str&gt;</code> |</p>
</li>
<li><p>贪婪和懒惰匹配</p>
<p>正则表达式的匹配模式分为<strong>贪婪匹配</strong>和<strong>懒惰匹配</strong>。简单地说，<strong>贪婪匹配</strong>试图在合乎要求的前提下匹配尽可能多的字符，而<strong>懒惰匹配</strong>则使v到的字符尽可能少。</p>
<p>在正则表达式中，直接输入限定符进行的匹配全部都是<strong>贪婪匹配</strong>。例如对于字符串<code>[...]&lt;p&gt;hello world!&lt;/p&gt;[...]</code>，当我们使用正则表达式<code>&lt;.+&gt;</code>进行匹配，结果为<code>hello world!</code>，这时进行了<em>匹配尽可能多的字符</em>的<strong>贪婪匹配</strong>；而当我们将正则表达式修改为<code>&lt;.+?&gt;</code>时，便进行了<em>匹配尽可能少的字符</em>的<strong>懒惰匹配</strong>，这时的结果为<code>&lt;p&gt;</code>和<code>&lt;/p&gt;</code>。</p>
</li>
</ul>
<h1 id="0x03-Python中的re库"><a href="#0x03-Python中的re库" class="headerlink" title="0x03 | Python中的re库"></a>0x03 | Python中的re库</h1><p>Python自带了一个正则表达式模块，其名为<code>re</code>，下面是该库的一个简单示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;hello world! I&#x27;m happy and I love regex!&quot;</span></span><br><span class="line">reg = <span class="string">&quot;[helopay]+&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.compile 函数</span></span><br><span class="line"><span class="comment"># 用于编译正则表达式</span></span><br><span class="line"><span class="comment"># 使用编译后的正则表达式对象相较于直接使用正则字符串有明显的性能提升</span></span><br><span class="line">compiled_pattern = re.<span class="built_in">compile</span>(reg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.match函数</span></span><br><span class="line"><span class="comment"># 从字符串的开始进行匹配，若字符串从开始就不符合正则表达式则返回None</span></span><br><span class="line"><span class="comment"># 只会返回第一个匹配项</span></span><br><span class="line"><span class="built_in">print</span>(re.<span class="keyword">match</span>(compiled_pattern ,<span class="built_in">str</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.search函数</span></span><br><span class="line"><span class="comment"># 对整个字符串进行匹配，直到找到匹配项或者读到尾部</span></span><br><span class="line"><span class="comment"># 只会返回第一个匹配项</span></span><br><span class="line"><span class="built_in">print</span>(re.search(compiled_pattern ,<span class="built_in">str</span>).group())</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.findall函数</span></span><br><span class="line"><span class="comment"># 返回由所有匹配项组成的列表</span></span><br><span class="line"><span class="built_in">print</span>(re.findall(compiled_pattern ,<span class="built_in">str</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.finditer函数</span></span><br><span class="line"><span class="comment"># 类似findall，但返回迭代器</span></span><br><span class="line">it = re.finditer(compiled_pattern,<span class="built_in">str</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">match</span>.group)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.sub函数</span></span><br><span class="line"><span class="comment"># 用于替换字符串中的匹配项</span></span><br><span class="line"><span class="comment"># 其中,count表示匹配替换的最大次数，默认为0，表示全部替换</span></span><br><span class="line">re.sub(compiled_pattern ,<span class="string">&quot;替换的字符串，也可以是一个函数&quot;</span>,<span class="built_in">str</span>,count=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.split函数</span></span><br><span class="line"><span class="comment"># 按能匹配的子串对原字符串进行分割，然后返回列表</span></span><br><span class="line"><span class="built_in">print</span>(re.split(compiled_pattern,<span class="built_in">str</span>))</span><br></pre></td></tr></table></figure>
<h1 id="0x04-C-标准库中的regex"><a href="#0x04-C-标准库中的regex" class="headerlink" title="0x04 | C++标准库中的regex"></a>0x04 | C++标准库中的regex</h1><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><p><code>std::regex</code>是<code>C++ 11</code>的特性，请确保你的编译器支持且已打开<code>C++ 11</code>标准。</p>
<h2 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h2><p><code>regex</code>库是围绕着<code>std::regex</code>类运行的，你可以通过如下形式创建一个正则表达式对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>regex</code>库中数据（<em>指正则表达式对象</em> ）与算法是分离的，应该使用<code>std::regex_match</code>等函数进行正则操作。</p>
<h2 id="正则语法支持"><a href="#正则语法支持" class="headerlink" title="正则语法支持"></a>正则语法支持</h2><p><code>regex</code>库支持以下六种正则表达式语法：</p>
<ul>
<li><p>ECMAScript（默认）</p>
</li>
<li><p>basic</p>
</li>
<li><p>extended</p>
</li>
<li><p>awk</p>
</li>
<li><p>grep</p>
</li>
<li><p>egrep</p>
</li>
</ul>
<p>你可以通过如下语句手动指定正则语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">regex <span class="title">e</span><span class="params">(<span class="string">&quot;^a.&quot;</span>,regex_constants::grep)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="匹配操作"><a href="#匹配操作" class="headerlink" title="匹配操作"></a>匹配操作</h2><p><code>std::regex_match</code>函数实现了正则匹配功能。</p>
<p>该函数会严格地检查字符串是否符合正则表达式所表示的格式，符合则返回<code>true</code>，否则<code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;.*&gt;.*&lt;/.*&gt;&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; (std::<span class="built_in">regex_match</span>(<span class="string">&quot;&lt;p&gt;hello&lt;/p&gt;&quot;</span>, reg) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="搜索操作"><a href="#搜索操作" class="headerlink" title="搜索操作"></a>搜索操作</h2><p><code>std::regex_search</code>函数实现了正则搜索功能。</p>
<p>该函数会检查是否有匹配项并将其全部返回，与<code>std::regex_match</code>不同的是，该函数并不会严格的要求字符串必须符合正则表达式所表示的格式，只是进行搜索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;&lt;(.*)&gt;(.*)&lt;/(\\1)&gt;&quot;</span>)</span></span>;</span><br><span class="line">std::cmatch matches;</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(<span class="string">&quot;certain str...&lt;p&gt;world&lt;/p&gt;456&quot;</span>, matches, reg))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : m)</span><br><span class="line">		std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h2><p><code>std::regex_replace</code>函数提供了正则替换功能。</p>
<p>该函数会将字符串中匹配到的部分全部替换为指定的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;\&quot;C++\&quot; in C++ is good, I mean \&quot;C++\&quot; for sure!&quot;</span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;\&quot;.*\&quot;&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">regex_replace</span>(str, reg, <span class="string">&quot;Regex&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="分词操作"><a href="#分词操作" class="headerlink" title="分词操作"></a>分词操作</h2><p><code>regex_token_iterator</code>函数提供了正则分词功能。</p>
<p>该函数会将字符串按照匹配到的字符串位置进行分割。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Regex;is;good;!&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;;&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::sregex_token_iterator <span class="title">pos</span><span class="params">(std::begin(str), std::end(str), reg, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(pos) end;</span><br><span class="line"><span class="keyword">for</span> (; pos != end; ++pos)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; pos-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/28/%E5%9F%BA%E4%BA%8EC-%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%A8%E4%BA%8EOpenAL%E7%9A%84-wav%E9%9F%B3%E9%A2%91%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/28/%E5%9F%BA%E4%BA%8EC-%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%A8%E4%BA%8EOpenAL%E7%9A%84-wav%E9%9F%B3%E9%A2%91%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">基于C++实现的用于OpenAL的 .wav音频加载器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-28 11:36:07" itemprop="dateCreated datePublished" datetime="2022-10-28T11:36:07+08:00">2022-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:21:04" itemprop="dateModified" datetime="2022-11-14T10:21:04+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 | 前言"></a>0x00 | 前言</h1><p>近日学习OpenAL，想从最简单的.wav格式入手，但苦于找不到合适的解析库，最终写下此文。</p>
<p>另，该库已开源</p>
<p><a target="_blank" rel="noopener" href="https://github.com/IAKSH/libwavaudio">IAKSH/libwavaudio (github.com)</a></p>
<h1 id="0x01-wav格式的标准结构"><a href="#0x01-wav格式的标准结构" class="headerlink" title="0x01 | .wav格式的标准结构"></a>0x01 | .wav格式的标准结构</h1><p>.wav音频格式按照一定的采样率（通常是<code>44.1KHz</code>，和CD音频一样）保存了音频的波形数据，不进行任何压缩，其数据结构简单易懂，十分便于操作。</p>
<p>标准的.wav音频文件主要由以下部分组成：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5546e76b98bd758004361b35827c5d63.png" alt="xh4sOK.png"></p>
<p>如图所示，整个文件大致分为三个部分:</p>
<ul>
<li><p>RIFF Chunk（文件头）</p>
<p>这一部分是资源交换档案标准（Resource Interchange File Format）所规定的文件头，Windows操作系统中许多媒体文件格式，如<code>.wav</code>和<code>.avi</code>，均遵循这一标准。这一文件头的出现表示该文件是一个标准的RIFF文件，可以按照RIFF标准对其进行解析。</p>
<p>RIFF Chunk的标准大小为<code>12Byte</code>，由三个<code>4Byte</code>数据组成，它们分别是：</p>
<ul>
<li><p>ChunkID（4Byte）</p>
<p>描述该区块的类别，对于RIFF Chunk，其值应为”RIFF”</p>
</li>
<li><p>ChunkSize（4Byte）</p>
<p>块大小，单位Byte，描述<strong>除<code>ChunkID</code>与<code>ChunkSize</code>所占用的8字节外的</strong>整个RIFF标准文件的大小</p>
</li>
<li><p>Format（4Byte）</p>
<p>描述该RIFF标准文件内的媒体数据格式，对于我们的.wav文件，其值应该是”WAVE”</p>
</li>
</ul>
</li>
<li><p>fmt Chunk</p>
<p>这一部分是音频数据的格式块，描述了该音频数据的格式以及相关参数，如采样率，码率等。</p>
<p>在.wav格式中，fmt Chunk的标准大小是<code>24Byte</code>，由4个<code>4Byte</code>数据和4个<code>2Byte</code>数据组成，从头至尾以此为：</p>
<ul>
<li><p>SubChunk1ID（4Byte）</p>
<p>标明这是一个子区块，同时描述该区块的类别，对于fmt Chunk，此值应为”fmt”</p>
</li>
<li><p>SubChunk1Size（4Byte）</p>
<p>描述了该子区块（fmt Chunk）<strong>除<code>SubChunk1ID</code>和<code>SubChunk1Size</code>所占用的8字节外的</strong>大小（单位Byte）</p>
</li>
<li><p>AudioFormat（2Byte）</p>
<p>描述了音频数据的格式，对于我们的.wav文件，其值通常为1。</p>
</li>
<li><p>NumChannels（2Byte）</p>
<p>描述了音频数据的总通道数</p>
</li>
<li><p>SampleRate（4Byte）</p>
<p>描述了音频数据的采样率（每个通道每秒包含多少帧数据），对于我们的.wav文件，这个值通常是<code>44100</code></p>
</li>
<li><p>ByteRate（4Byte）</p>
<p>描述音频数据每秒钟的音频包含多少字节的数据</p>
</li>
<li><p>BlockAlign（2Byte）</p>
<p>描述音频数据每帧所有通道总共有多少字节的数据</p>
</li>
<li><p>BitsPerSample（2Byte）</p>
<p>描述每帧包含多少bit数据</p>
</li>
</ul>
</li>
<li><p>data Chunk</p>
<ul>
<li><p>SubChunk2ID（4Byte）</p>
<p>标明这是一个子区块，同时描述该区块的类别，对于data Chunk，其值应为<code>data</code></p>
</li>
<li><p>SubChunk2Size（4Byte）</p>
<p>描述音频数据（data）的总大小（单位Byte）</p>
</li>
<li><p>data（大小不定）</p>
<p>音频波形帧数据，即<code>PCM</code>（脉冲编码调制）数据，整个文件中真正保存音频的地方。其大小为<code>SubChunk2Size</code>的值（单位Byte）。</p>
</li>
</ul>
</li>
</ul>
<h1 id="0x02-wav格式的非标准结构"><a href="#0x02-wav格式的非标准结构" class="headerlink" title="0x02 | .wav格式的非标准结构"></a>0x02 | .wav格式的非标准结构</h1><p>和PE格式一样，<code>.wav</code>的各数据块的位置是不定的。对于某些编码实现，各个Chunk之间完全可能被随意插入某些数据，比如，ffmpeg在转换音频格式时会在文件中插入<code>libavformat</code>的版本信息。</p>
<p>使用互联网上的一些在线mp3转wav网页得到的wav文件，通过16进制编辑器打开后可以发现这一现象：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/46be692d2d1ced6ffdd07924fe74d180.png" alt="xh4OYj.png"></p>
<p>这其实是合乎RIFF标准的，但并不是我们所理解的普适化的”.wav标准格式”。这意味着一个.wav文件中各Chunk的偏移量并不是确定的，我们需要通过ChunkID动态地解析地址。</p>
<h1 id="0x03-C-按字节读取文件的方法"><a href="#0x03-C-按字节读取文件的方法" class="headerlink" title="0x03 | C++按字节读取文件的方法"></a>0x03 | C++按字节读取文件的方法</h1><p>想要动态解析Chunk，我们就需要按字节读取文件，然后解析。C++标准库中的<code>fstream</code>库提供了相关功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> noexcpet</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fs</span><span class="params">(<span class="string">&quot;test.wav&quot;</span>,std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">    fs.<span class="built_in">seekg</span>(<span class="number">1</span>,std::ios::beg);</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    fs.<span class="built_in">read</span>(&amp;c,<span class="number">1</span>);</span><br><span class="line">    fs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用<code>fstream</code>库打开了<code>test.wav</code>文件，并读取了其第2个字节到变量<code>c</code>中。</p>
<p>其中，我们通过<code>std::ifstream::seekg(...)</code>函数对文件流进行了偏移以读取指定地址。使用<code>std::ifstream::read(...)</code>函数在文件流中读取了指定大小的数据到<code>c</code>中。</p>
<h1 id="0x04-OpenAL播放音频的流程"><a href="#0x04-OpenAL播放音频的流程" class="headerlink" title="0x04 | OpenAL播放音频的流程"></a>0x04 | OpenAL播放音频的流程</h1><p>我们还需要将解码出的波形数据播放出来以验证代码是否按照我们的期望运行，理所当然，这里我选用了OpenAL。</p>
<p>OpenAL API的设计与OpenGL API高度相似，但其主要围绕两种对象进行操作：</p>
<ol>
<li><p>Buffer（缓存）</p>
<p>是音频数据的缓存，实际上其内存由OpenAL状态机管理，我们只能拿到其ID。</p>
</li>
<li><p>Source（声源）</p>
<p>声源用于播放音频，其记录了自己的方位，速度属性，以进行混音。</p>
</li>
</ol>
<p>除此之外，还需要建立OpenAL上下文，加载音频设备。我们可以粗略的将其封装为一个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ALCdevice *device = <span class="literal">nullptr</span>;</span><br><span class="line">    ALCcontext *context = <span class="literal">nullptr</span>;</span><br><span class="line">    ALuint audioSource;</span><br><span class="line">    ALfloat audioSourcePos[<span class="number">3</span>];</span><br><span class="line">    ALfloat audioSourceVel[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initializeOpenAL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        device = <span class="built_in">alcOpenDevice</span>(<span class="literal">nullptr</span>); <span class="comment">// open defeault device</span></span><br><span class="line">        context = <span class="built_in">alcCreateContext</span>(device, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">alcMakeContextCurrent</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeOpenAL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">alcMakeContextCurrent</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">alcDestroyContext</span>(context);</span><br><span class="line">        <span class="built_in">alcCloseDevice</span>(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AudioPlayer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initializeOpenAL</span>();</span><br><span class="line">        <span class="built_in">alGenSources</span>(<span class="number">1</span>, &amp;audioSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AudioPlayer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closeOpenAL</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(wava::WavAudio &amp;wav, <span class="type">bool</span> loopable, <span class="type">float</span> posX, <span class="type">float</span> posY, <span class="type">float</span> posZ, <span class="type">float</span> velX, <span class="type">float</span> velY, <span class="type">float</span> velZ)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        audioSourcePos[<span class="number">0</span>] = posX;</span><br><span class="line">        audioSourcePos[<span class="number">1</span>] = posY;</span><br><span class="line">        audioSourcePos[<span class="number">2</span>] = posZ;</span><br><span class="line"></span><br><span class="line">        audioSourceVel[<span class="number">0</span>] = velX;</span><br><span class="line">        audioSourceVel[<span class="number">1</span>] = velY;</span><br><span class="line">        audioSourceVel[<span class="number">2</span>] = velZ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">alSourcei</span>(audioSource, AL_BUFFER, wav.<span class="built_in">getBuffer</span>());</span><br><span class="line">        <span class="built_in">alSourcef</span>(audioSource, AL_PITCH, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">alSourcef</span>(audioSource, AL_GAIN, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">alSourcefv</span>(audioSource, AL_POSITION, audioSourcePos);</span><br><span class="line">        <span class="built_in">alSourcefv</span>(audioSource, AL_VELOCITY, audioSourceVel);</span><br><span class="line">        <span class="built_in">alSourcei</span>(audioSource, AL_LOOPING, <span class="built_in">static_cast</span>&lt;ALboolean&gt;(loopable));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">alSourcePlay</span>(audioSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">alSourceStop</span>(audioSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="0x05-构建-wav加载器"><a href="#0x05-构建-wav加载器" class="headerlink" title="0x05 | 构建.wav加载器"></a>0x05 | 构建.wav加载器</h1><p>我们的目标是解析出.wav文件中的<code>PCM</code>数据，在上述分析的基础上，我们可以写出以下代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wavaudio.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AL/al.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;AL/alc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> wava</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WavAudio</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">uint32_t</span> buffer;</span><br><span class="line">        <span class="type">bool</span> loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> loaded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RIFF chunk (main chunk)</span></span><br><span class="line">        <span class="type">uint32_t</span> chunkSize;</span><br><span class="line">        <span class="type">char</span> format[<span class="number">5</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sub-chunk 1 (fmt chunk)</span></span><br><span class="line">        <span class="type">uint32_t</span> subChunk1Size;</span><br><span class="line">        <span class="type">uint16_t</span> audioFormat;</span><br><span class="line">        <span class="type">uint16_t</span> numChannels;</span><br><span class="line">        <span class="type">uint32_t</span> sampleRate;</span><br><span class="line">        <span class="type">uint32_t</span> byteRate;</span><br><span class="line">        <span class="type">uint16_t</span> blockAlign;</span><br><span class="line">        <span class="type">uint16_t</span> bitsPerSample;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sub-chunk 2 (data)</span></span><br><span class="line">        <span class="type">uint32_t</span> subChunk2Size;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getFileCursorMark</span><span class="params">(std::ifstream &amp;fs, std::string mark)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">WavAudio</span>();</span><br><span class="line">        <span class="built_in">WavAudio</span>(<span class="type">const</span> <span class="type">char</span> *path);</span><br><span class="line">        ~<span class="built_in">WavAudio</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">uint32_t</span> <span class="title">getBuffer</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wavaudio.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wavaudio.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> wava::WavAudio::<span class="built_in">getFileCursorMark</span>(std::ifstream &amp;fs, std::string mark)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = mark.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">char</span> buf[len + <span class="number">1</span>];</span><br><span class="line">    buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fs.<span class="built_in">eof</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        fs.<span class="built_in">seekg</span>(i++, std::ios::beg);</span><br><span class="line">        fs.<span class="built_in">read</span>(buf, <span class="built_in">sizeof</span>(<span class="type">char</span>) * len);</span><br><span class="line">        <span class="keyword">if</span> (mark.<span class="built_in">compare</span>(buf) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;[libwavaudio] ERROR: failed to locate mark (&quot;</span> &lt;&lt; mark &lt;&lt; <span class="string">&quot;) in moveFileCursorToMark()\n&quot;</span>;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wava::WavAudio::<span class="built_in">WavAudio</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wava::WavAudio::<span class="built_in">WavAudio</span>(<span class="type">const</span> <span class="type">char</span> *path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">load</span>(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wava::WavAudio::~<span class="built_in">WavAudio</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">alDeleteBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> wava::WavAudio::<span class="built_in">load</span>(<span class="type">const</span> <span class="type">char</span> *path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">fs</span><span class="params">(path, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!fs)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[libwavaudio] ERROR: can&#x27;t open file (&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">        <span class="built_in">abort</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i = <span class="built_in">getFileCursorMark</span>(fs, <span class="string">&quot;RIFF&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">4</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;chunkSize, <span class="number">4</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">8</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;format, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(format).<span class="built_in">compare</span>(<span class="string">&quot;WAVE&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[libwavaudio] ERROR: trying to load a none-wav format file (&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">getFileCursorMark</span>(fs, <span class="string">&quot;fmt&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">4</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;subChunk1Size, <span class="number">4</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">8</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;audioFormat, <span class="number">2</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">10</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;numChannels, <span class="number">2</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">12</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;sampleRate, <span class="number">4</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">16</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;byteRate, <span class="number">4</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">20</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;blockAlign, <span class="number">2</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">22</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;bitsPerSample, <span class="number">2</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">24</span>, std::ios::beg);</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">getFileCursorMark</span>(fs, <span class="string">&quot;data&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">4</span>, std::ios::beg);</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;subChunk2Size, <span class="number">4</span>);</span><br><span class="line">    fs.<span class="built_in">seekg</span>(i + <span class="number">8</span>, std::ios::beg);</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">unsigned</span> <span class="type">char</span>[subChunk2Size];</span><br><span class="line">    fs.<span class="built_in">read</span>((<span class="type">char</span> *)data, subChunk2Size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load data to OpenAL buffer</span></span><br><span class="line">    <span class="built_in">alGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="keyword">if</span> (bitsPerSample == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numChannels == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">alBufferData</span>(buffer, AL_FORMAT_MONO16, data, subChunk2Size, sampleRate);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numChannels == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">alBufferData</span>(buffer, AL_FORMAT_STEREO16, data, subChunk2Size, sampleRate);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bitsPerSample == <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numChannels == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">alBufferData</span>(buffer, AL_FORMAT_MONO8, data, subChunk2Size, sampleRate);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numChannels == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">alBufferData</span>(buffer, AL_FORMAT_STEREO8, data, subChunk2Size, sampleRate);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release data</span></span><br><span class="line">    <span class="keyword">delete</span>[] data;</span><br><span class="line">    fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> wava::WavAudio::<span class="built_in">getBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (loaded)</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;[libwavaudio] ERROR: called getBuffer() from an unloaded WavAudio\n&quot;</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x06-测试"><a href="#0x06-测试" class="headerlink" title="0x06 | 测试"></a>0x06 | 测试</h1><p>我使用上述<code>AudioPlayer</code>和<code>WavAudio</code>类编写了简单的测试代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../wavaudio.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ALCdevice *device = <span class="literal">nullptr</span>;</span><br><span class="line">    ALCcontext *context = <span class="literal">nullptr</span>;</span><br><span class="line">    ALuint audioSource;</span><br><span class="line">    ALfloat audioSourcePos[<span class="number">3</span>];</span><br><span class="line">    ALfloat audioSourceVel[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initializeOpenAL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        device = <span class="built_in">alcOpenDevice</span>(<span class="literal">nullptr</span>); <span class="comment">// open defeault device</span></span><br><span class="line">        context = <span class="built_in">alcCreateContext</span>(device, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">alcMakeContextCurrent</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">closeOpenAL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">alcMakeContextCurrent</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">alcDestroyContext</span>(context);</span><br><span class="line">        <span class="built_in">alcCloseDevice</span>(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AudioPlayer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">initializeOpenAL</span>();</span><br><span class="line">        <span class="built_in">alGenSources</span>(<span class="number">1</span>, &amp;audioSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">AudioPlayer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">closeOpenAL</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">(wava::WavAudio &amp;wav, <span class="type">bool</span> loopable, <span class="type">float</span> posX, <span class="type">float</span> posY, <span class="type">float</span> posZ, <span class="type">float</span> velX, <span class="type">float</span> velY, <span class="type">float</span> velZ)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        audioSourcePos[<span class="number">0</span>] = posX;</span><br><span class="line">        audioSourcePos[<span class="number">1</span>] = posY;</span><br><span class="line">        audioSourcePos[<span class="number">2</span>] = posZ;</span><br><span class="line"></span><br><span class="line">        audioSourceVel[<span class="number">0</span>] = velX;</span><br><span class="line">        audioSourceVel[<span class="number">1</span>] = velY;</span><br><span class="line">        audioSourceVel[<span class="number">2</span>] = velZ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">alSourcei</span>(audioSource, AL_BUFFER, wav.<span class="built_in">getBuffer</span>());</span><br><span class="line">        <span class="built_in">alSourcef</span>(audioSource, AL_PITCH, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">alSourcef</span>(audioSource, AL_GAIN, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="built_in">alSourcefv</span>(audioSource, AL_POSITION, audioSourcePos);</span><br><span class="line">        <span class="built_in">alSourcefv</span>(audioSource, AL_VELOCITY, audioSourceVel);</span><br><span class="line">        <span class="built_in">alSourcei</span>(audioSource, AL_LOOPING, <span class="built_in">static_cast</span>&lt;ALboolean&gt;(loopable));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">alSourcePlay</span>(audioSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">alSourceStop</span>(audioSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    AudioPlayer ap;</span><br><span class="line">    <span class="function">wava::WavAudio <span class="title">wa</span><span class="params">(<span class="string">&quot;../test/sounds/heart.wav&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    ap.<span class="built_in">play</span>(wa, <span class="literal">false</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;finished!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码尝试加载位于<code>../test/sounds/heart.wav</code>的.wav文件，并使用<code>AudioPlayer</code>调用OpenAL进行播放。如果你使用我的这个.wav文件，运行该代码你应该可以听见不间断的心跳声。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/20/const-type-%E5%92%8C-const-type-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/20/const-type-%E5%92%8C-const-type-const/" class="post-title-link" itemprop="url">const type 和 const type* const</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-20 19:53:32" itemprop="dateCreated datePublished" datetime="2022-10-20T19:53:32+08:00">2022-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:21:14" itemprop="dateModified" datetime="2022-11-14T10:21:14+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>你可能在<code>C++</code>中见过关于<code>const</code>关键字的这两种语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* A = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> B = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>简单地说，前者可以读作： <em>常量int的指针 A</em></p>
<p>而后者可以读作： <em>常量int的常量指针 B</em></p>
<p>它们的区别在于：<code>const int*</code>可以“重定向”，而<code>const int* const</code>不行。</p>
<p>具体请看下文。</p>
<h1 id="修改值"><a href="#修改值" class="headerlink" title="修改值"></a>修改值</h1><p>显然，两者都表示其是一个整型指针常量，其所指向的值的内容都不可更改，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* A = new <span class="type">int</span>(<span class="number">114</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> B = new <span class="type">int</span>(<span class="number">514</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> noexcept</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 错误的写法</span></span><br><span class="line">    (*A)++;</span><br><span class="line">    (*B)++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码尝试修改<code>const int*</code>和<code>const int* const</code>所指向的内存，然而这是错误的，如果你有现代化的静态代码检查器，上述代码甚至在编译前就会报错。</p>
<p>由此可知，<code>const int*</code>和<code>const int* const</code>所指向的<strong>内存</strong>都是不可修改的。</p>
<h1 id="修改地址"><a href="#修改地址" class="headerlink" title="修改地址"></a>修改地址</h1><p>那么，如果我们尝试修改<code>const int*</code>和<code>const int* const</code>所指向的值的地址呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* A = new <span class="type">int</span>(<span class="number">114</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> B = new <span class="type">int</span>(<span class="number">514</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> noexcept</span><br><span class="line">&#123;</span><br><span class="line">	A = B;</span><br><span class="line">	B = A;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; A &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; B &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码尝试修改<code>const int*</code>和<code>const int* const</code>所指向的值的地址，然而经过静态代码检查可以发现，<code>B = A;</code>是无法通过编译的。</p>
<p>在<code>Visual Studio 2022</code>中返回的错误描述是<code>表达式必须是可修改的左值</code>，也就是说<code>const int* const</code>是不可重定向的（即修改其所指向的内存的<strong>地址</strong>），而<code>const int*</code>可以。</p>
<h1 id="const语法"><a href="#const语法" class="headerlink" title="* const语法"></a>* const语法</h1><p>如果你真的难以理解<code>int* const</code>，可以尝试将其写为<code>int *const</code>，将星号前置只是我个人的习惯。</p>
<p>常量指针语法是可以单独使用的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">115</span>);</span><br><span class="line">	(*a)--;</span><br><span class="line">	std::cout &lt;&lt; *a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以试试运行上面的代码，最后输出的结果是114，证明了我们理论的正确。</p>
<p>相应的，尝试修改<code>int* const</code>所指向的内存的地址是无法通过编译的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* <span class="type">const</span> a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">115</span>);</span><br><span class="line">	<span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">	a = &amp;b;<span class="comment">// 在此处出错</span></span><br><span class="line">	std::cout &lt;&lt; *a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对于C语言"><a href="#对于C语言" class="headerlink" title="对于C语言"></a>对于C语言</h1><p>在C语言中也有同样的语法，或者说C++中的const语法正是从C语言中继承的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> A = &amp;a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> B = &amp;b;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* C = &amp;c;</span><br><span class="line">    (*A)++;</span><br><span class="line">    A = &amp;b;<span class="comment">// 编译期报错</span></span><br><span class="line">    (*B)++;<span class="comment">// 编译期报错</span></span><br><span class="line">    B = &amp;a;<span class="comment">// 编译期报错</span></span><br><span class="line">    (*C)++;<span class="comment">// 编译期报错</span></span><br><span class="line">    C = &amp;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/19/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/19/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">C语言位运算的一些应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-19 23:25:58" itemprop="dateCreated datePublished" datetime="2022-10-19T23:25:58+08:00">2022-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:21:23" itemprop="dateModified" datetime="2022-11-14T10:21:23+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单变量表示多状态"><a href="#单变量表示多状态" class="headerlink" title="单变量表示多状态"></a>单变量表示多状态</h1><p>如果你有使用过SDL2库，你一定见过这样的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);</span><br></pre></td></tr></table></figure>
<p>这其中有一个奇怪的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC</span><br></pre></td></tr></table></figure>
<p>这里只输入了一个参数，但是就好像是输入了两个</p>
<p>在C++标准库中也有类似的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::fstream fs;</span><br><span class="line">fs.open(<span class="string">&quot;a.data&quot;</span>,<span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary);</span><br></pre></td></tr></table></figure>
<p>这是怎么回事呢？我们以<code>std::ios::binary</code>为例，先来看看它在<code>iso_base.h</code>中的定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...  </span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">_Ios_Openmode</span> </span><br><span class="line">    &#123; </span><br><span class="line">      _S_app 		= <span class="number">1L</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">      _S_ate 		= <span class="number">1L</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">      _S_bin 		= <span class="number">1L</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">      _S_in 		= <span class="number">1L</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">      _S_out 		= <span class="number">1L</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">      _S_trunc 		= <span class="number">1L</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">      _S_noreplace 	= <span class="number">1L</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">      _S_ios_openmode_end = <span class="number">1L</span> &lt;&lt; <span class="number">16</span>,</span><br><span class="line">      _S_ios_openmode_max = __INT_MAX__,</span><br><span class="line">      _S_ios_openmode_min = ~__INT_MAX__</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> openmode binary =	_S_bin;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>可以看出C++标准库的做法是将每一个“标签“用一个64bit（即8byte）整数<code>000...001</code>按位左移不同的位数得到。使该64bit数据的每一位都表示一个标签的真假，一共可以表示64个不同的标签，再用按位或操作即可将多个标签混合到一个值，具体如下表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>值1</th>
<th>值2</th>
<th>两者按位或</th>
<th>结果描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>00..001</td>
<td>00..010</td>
<td>00..011</td>
<td>读结果后两位可知，值1，2均表示真</td>
</tr>
<tr>
<td>00..000</td>
<td>00..010</td>
<td>00..010</td>
<td>读结果后两位可知，值1，2分别表示假，真</td>
</tr>
<tr>
<td>00..001</td>
<td>00..000</td>
<td>00..001</td>
<td>读结果后两位可知，值1，2分别表示真，假</td>
</tr>
<tr>
<td>00..000</td>
<td>00..000</td>
<td>00..000</td>
<td>读结果后两位可知，值1，2均表示假</td>
</tr>
</tbody>
</table>
</div>
<p>可以写一个C程序来验证上述操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int32_t 自然是32位二进制</span></span><br><span class="line"><span class="comment">// 一个八进制数表示两个比特位</span></span><br><span class="line"><span class="comment">// 一个十六进制数表示四个比特位</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// 0x0 = 0000</span></span><br><span class="line"><span class="comment">// 0xF = 1111</span></span><br><span class="line"><span class="comment">// 0xFF = 1111 1111（空格仅为方便阅读，可去除）</span></span><br><span class="line"><span class="comment">// 0xAC = 1010 1100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> input,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mark,i;</span><br><span class="line">    <span class="keyword">for</span>(mark = <span class="number">0</span>;val != <span class="number">1</span>;val &gt;&gt;= <span class="number">1</span>) mark++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; mark;i++) input &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (input &amp; val) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;                  <span class="comment">//bin: 0000 ... 0000 0001   hex: 0x0...01</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;                  <span class="comment">//bin: 0000 ... 0000 0010   hex: 0x0...02</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">4</span>;                  <span class="comment">//bin: 0000 ... 0000 0100   hex: 0x0...04</span></span><br><span class="line">    <span class="type">int</span> d = <span class="number">8</span>;                  <span class="comment">//bin: 0000 ... 0000 1000   hex: 0x0...08</span></span><br><span class="line">    <span class="type">int</span> e = <span class="number">16</span>;                 <span class="comment">//bin: 0000 ... 0001 0000   hex: 0x0...10</span></span><br><span class="line">    <span class="type">int</span> input = a | b | c | d;  <span class="comment">//bin: 0000 ... 0000 1111   hex: 0x0...0F</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,check(input,a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,check(input,b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,check(input,c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,check(input,d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,check(input,e));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释中的<code>bin</code>表示二进制，<code>hex</code>表示十六进制，此处赋值时直接使用了十进制。</p>
<h1 id="更快的乘2运算"><a href="#更快的乘2运算" class="headerlink" title="更快的乘2运算"></a>更快的乘2运算</h1><p>先来看几个二进制数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0001</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>2</td>
</tr>
<tr>
<td>0100</td>
<td>4</td>
</tr>
<tr>
<td>1000</td>
<td>8</td>
</tr>
</tbody>
</table>
</div>
<p>不难看出，亦不难证出一个二进制数按位左移1位即能使其乘以2。</p>
<p>术业有专攻，这种专门乘2的算法理应是要比传统的万用乘法运算符要快的，我们可以通过一个简单的C程序验证这个猜测。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> s,e;</span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) n *= <span class="number">2</span>;</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody>
<tr>
<td>n *= 2</td>
<td>4.257221 sec</td>
<td>4.125867 sec</td>
<td>4. 176448 sec</td>
<td>4.186512 sec</td>
</tr>
<tr>
<td>n &lt;&lt;= 1</td>
<td>3.519814 sec</td>
<td>3.600015 sec</td>
<td>3.618779 sec</td>
<td>3.579536 sec</td>
</tr>
</tbody>
</table>
</div>
<p>确实有所提升，事实上，大多数编译器启用代码优化后都会尝试将<code>n * 2</code>替换为<code>n &lt;&lt; 1</code>，以此提升程序性能。</p>
<h1 id="更快的除2运算"><a href="#更快的除2运算" class="headerlink" title="更快的除2运算"></a>更快的除2运算</h1><p>原理和上述乘2运算一样，测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">float</span> s,e;</span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) n /= <span class="number">2</span>;</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    n = <span class="number">10000</span>;</span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody>
<tr>
<td>n /= 2</td>
<td>7.669598 sec</td>
<td>7.514236 sec</td>
<td>7.551863 sec</td>
<td>7.578565 sec</td>
</tr>
<tr>
<td>n &gt;&gt;= 1</td>
<td>3.414502 sec</td>
<td>3.584141 sec</td>
<td>3.611094 sec</td>
<td>3.536579 sec</td>
</tr>
</tbody>
</table>
</div>
<p>同样的，大多编译器也会在开启代码优化时尝试将<code>n /2</code>替换为<code>n &gt;&gt; 1</code>以提升性能。</p>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>哈希函数肯定离不开位运算，以<code>FNV-1a</code> 算法为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">fnv1a_32</span><span class="params">(<span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 32bit version of the algorithm FNV-1a</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> HASH_OFFSET_BASIS_32 = <span class="number">0x811C9DC5</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> FNV_PRIME_32         = <span class="number">16777619</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> hash = HASH_OFFSET_BASIS_32;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash *= FNV_PRIME_32;</span><br><span class="line">        hash ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>详见我的另一篇博文。</del></p>
<h1 id="位运算的一些奇怪用法"><a href="#位运算的一些奇怪用法" class="headerlink" title="位运算的一些奇怪用法"></a>位运算的一些奇怪用法</h1><h2 id="更快但有局限的模运算"><a href="#更快但有局限的模运算" class="headerlink" title="更快但有局限的模运算"></a>更快但有局限的模运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_MODE(M,N) ((M) &amp; ((N) - 1))</span></span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICK_MODE(M,N) ((M) &amp; ((N) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD 100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2</span></span><br><span class="line"><span class="comment">// 当且仅当 N = 2^n 时 QUICK_MODE(M,N) 可用，否则计算出错</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> s,e;</span><br><span class="line">    <span class="type">int</span> i,j,x1,x2,y = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) x1 = y % N;</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec\n&quot;</span>,(e-s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) x2 = QUICK_MODE(y, N);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec\n&quot;</span>,(e-s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,x1 == x2 ? <span class="string">&quot;PASSED&quot;</span>:<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5.105534 sec</span><br><span class="line">4.125605 sec</span><br><span class="line">PASSED</span><br></pre></td></tr></table></figure>
<h2 id="更慢但无中间值的交换"><a href="#更慢但无中间值的交换" class="headerlink" title="更慢但无中间值的交换"></a>更慢但无中间值的交换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">noval_swap</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    *m = *m ^ *n;</span><br><span class="line">    *n = *m ^ *n;</span><br><span class="line">    *m = *m ^ *n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traditional_swap</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> buffer = *m;</span><br><span class="line">    *m = *n;</span><br><span class="line">    *n = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noval_swap</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    *m = *m ^ *n;</span><br><span class="line">    *n = *m ^ *n;</span><br><span class="line">    *m = *m ^ *n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _m = *m, _n = *n;</span><br><span class="line">    traditional_swap(m, m);</span><br><span class="line">    noval_swap(&amp;_m,&amp;_n);</span><br><span class="line">    <span class="keyword">return</span> (_m == *n &amp;&amp; _n == *m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> s,e;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">3</span>,n = <span class="number">2</span>,i,j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,check(&amp;m,&amp;n)?<span class="string">&quot;PASSED&quot;</span>:<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) traditional_swap(&amp;m, &amp;n);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec\n&quot;</span>,(e-s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) noval_swap(&amp;m, &amp;n);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec\n&quot;</span>,(e-s)/CLOCKS_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="炫酷但更慢的求绝对值"><a href="#炫酷但更慢的求绝对值" class="headerlink" title="炫酷但更慢的求绝对值"></a>炫酷但更慢的求绝对值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(N) ((((N) &gt;&gt; 31) ^ (N)) - ((N) &gt;&gt; 31))</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS(N) ((((N) &gt;&gt; 31) ^ (N)) - ((N) &gt;&gt; 31))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? n : -n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,m,n = <span class="number">-114</span>;</span><br><span class="line">    <span class="type">float</span> s,e;</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) m = <span class="built_in">abs</span>(n);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) m = <span class="built_in">abs</span>(n);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    s = clock();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; PCD;i++) <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; PCD;j++) m = ABS(n);</span><br><span class="line">    e = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf sec.\n&quot;</span>,(e - s)/CLOCKS_PER_SEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.285493 sec.</span><br><span class="line">4.521450 sec.</span><br><span class="line">5.298813 sec.</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/11/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">计数排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-11 18:55:29" itemprop="dateCreated datePublished" datetime="2022-10-11T18:55:29+08:00">2022-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:21:34" itemprop="dateModified" datetime="2022-11-14T10:21:34+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>拿空间换时间的典型算法。以新构建的数组的下标标识原数组的某个数，以新构建的数组中该下标所对应的值记录原数组中该值出现的次数，然后构建新的数组以实现排序。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) <span class="keyword">if</span>(nums[i] &gt; max) max = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>),max + <span class="number">1</span>);<span class="comment">// 放在堆里，防止爆栈</span></span><br><span class="line">    <span class="keyword">if</span>(!count) <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>) * (max + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) count[nums[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; max + <span class="number">1</span>;i++) <span class="keyword">while</span>(count[i]-- &gt; <span class="number">0</span>) nums[j++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_AMOUNT 50000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALGORITHM_NAME <span class="string">&quot;O(n)查找最大值 + 计数排序 (Counting Sort)&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[DATA_AMOUNT];</span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) nums[i] = rand()%<span class="number">10001</span>;<span class="comment">//(0,10000)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start,end;</span><br><span class="line">    start = clock();</span><br><span class="line">    algorithm();</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;algorithm \&quot;%s\&quot; used %f sec to process %d data\n&quot;</span>,ALGORITHM_NAME,(<span class="type">float</span>)(end - start)/CLOCKS_PER_SEC,DATA_AMOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;PASSED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) <span class="keyword">if</span>(nums[i] &gt; max) max = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* count = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>),max + <span class="number">1</span>);<span class="comment">// 放在堆里，防止爆栈</span></span><br><span class="line">    <span class="keyword">if</span>(!count) <span class="built_in">abort</span>();</span><br><span class="line">    <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>) * (max + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) count[nums[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; max + <span class="number">1</span>;i++) <span class="keyword">while</span>(count[i]-- &gt; <span class="number">0</span>) nums[j++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><div class="table-container">
<table>
<thead>
<tr>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.000335 sec</td>
<td>0.000297 sec</td>
<td>0.000360 sec</td>
<td>0.000331 sec</td>
</tr>
</tbody>
</table>
</div>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><ol>
<li><p>该算法未进行任何数值比较，相比冒泡等基于比较的算法有明显优势。</p>
</li>
<li><p>该算法时间复杂度为$O(n+k)$</p>
</li>
<li><p>该算法使用格外空间以换取更少的时间消耗</p>
</li>
<li><p>该算法不稳定，若要实现稳定性，需要格外编写代码。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">选择排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-07 16:59:03 / 修改时间：17:00:26" itemprop="dateCreated datePublished" datetime="2022-10-07T16:59:03+08:00">2022-10-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>多次遍历，依次选出每次的最大&#x2F;小项进行排列。</p>
<h1 id="实现（无缓存）"><a href="#实现（无缓存）" class="headerlink" title="实现（无缓存）"></a>实现（无缓存）</h1><p>这是传统的选择排序，不使用格外内存，就地交换值进行排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,buffer,minIndex,min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span>(j = i;j &lt; DATA_AMOUNT;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; min) min = nums[j];</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = nums[i];</span><br><span class="line">        nums[i] = min;</span><br><span class="line">        nums[minIndex] = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_AMOUNT 50000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALGORITHM_NAME <span class="string">&quot;不使用格外内存的选择排序&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[DATA_AMOUNT];</span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) nums[i] = rand()%<span class="number">10001</span>;<span class="comment">//(0,10000)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start,end;</span><br><span class="line">    start = clock();</span><br><span class="line">    algorithm();</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;algorithm \&quot;%s\&quot; used %f sec to process %d data\n&quot;</span>,ALGORITHM_NAME,(<span class="type">float</span>)(end - start)/CLOCKS_PER_SEC,DATA_AMOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;PASSED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,buffer,minIndex,min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span>(j = i;j &lt; DATA_AMOUNT;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; min) min = nums[j];</span><br><span class="line">            minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer = nums[i];</span><br><span class="line">        nums[i] = min;</span><br><span class="line">        nums[minIndex] = buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三次测试结果"><a href="#三次测试结果" class="headerlink" title="三次测试结果"></a>三次测试结果</h2><table>
<thead>
<tr>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>0.755189 sec</td>
<td>0.693200 sec</td>
<td>0.693922 sec</td>
<td>0.714104 sec</td>
</tr>
</tbody></table>
<h1 id="实现（有缓存）"><a href="#实现（有缓存）" class="headerlink" title="实现（有缓存）"></a>实现（有缓存）</h1><p>这是选择排序的一种优化方案，使用了格外的内存，节约了部分的交换耗时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> newNums[DATA_AMOUNT];</span><br><span class="line">    <span class="type">int</span> i,j,k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; DATA_AMOUNT - k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; min) min = nums[j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNums[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(nums,newNums,<span class="keyword">sizeof</span>(<span class="type">int</span>) * DATA_AMOUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_AMOUNT 50000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALGORITHM_NAME <span class="string">&quot;选择排序&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[DATA_AMOUNT];</span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) nums[i] = rand()%<span class="number">10001</span>;<span class="comment">//(0,10000)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start,end;</span><br><span class="line">    start = clock();</span><br><span class="line">    algorithm();</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;algorithm \&quot;%s\&quot; used %f sec to process %d data\n&quot;</span>,ALGORITHM_NAME,(<span class="type">float</span>)(end - start)/CLOCKS_PER_SEC,DATA_AMOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;PASSED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> newNums[DATA_AMOUNT];</span><br><span class="line">    <span class="type">int</span> i,j,k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; DATA_AMOUNT - k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; min) min = nums[j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        newNums[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(nums,newNums,<span class="keyword">sizeof</span>(<span class="type">int</span>) * DATA_AMOUNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三次测试结果-1"><a href="#三次测试结果-1" class="headerlink" title="三次测试结果"></a>三次测试结果</h2><table>
<thead>
<tr>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
<th>平均</th>
</tr>
</thead>
<tbody><tr>
<td>0.000145 sec</td>
<td>0.000106 sec</td>
<td>0.000153 sec</td>
<td>0.000135 sec</td>
</tr>
</tbody></table>
<h1 id="性能和稳定性"><a href="#性能和稳定性" class="headerlink" title="性能和稳定性"></a>性能和稳定性</h1><ol start="0">
<li><p>先说结论：比冒泡快，不稳定。</p>
</li>
<li><p>选择排序的时间复杂度和冒泡排序一样为$O(n^2)$，但交换次数比冒泡排序少，所以效率更高。</p>
</li>
<li><p>选择排序是不稳定的，这一点主要体现在无法区分相同值的前后顺序，例如有一序列：{5,8,5,2,9}，选择排序无法保证两个5在排序后依然按照之前的顺序排列。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/05/%E7%8C%B4%E5%AD%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/05/%E7%8C%B4%E5%AD%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">猴子排序算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-05 17:05:48" itemprop="dateCreated datePublished" datetime="2022-10-05T17:05:48+08:00">2022-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-14 10:21:47" itemprop="dateModified" datetime="2022-11-14T10:21:47+08:00">2022-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="乌洛波罗斯（衔尾蛇）"><a href="#乌洛波罗斯（衔尾蛇）" class="headerlink" title="乌洛波罗斯（衔尾蛇）"></a>乌洛波罗斯（衔尾蛇）</h1><p>不知道你有没有见过这个图案</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/514d6922a311578a992de6e2b6ee432e.jpeg" alt="图-衔尾蛇"></p>
<p>这是”衔尾蛇”，许多古老的民族都有关于它的神话，柏拉图形容其为“一头在自我吞食状态的宇宙始祖生物“，衔尾蛇是”不死之身”，且“拥有完美的生物结构”。千百年来，衔尾蛇被赋予了数不清的意义，其中就包括较易理解的“循环”，“无限”，以及偏向神学概念的“生死循环”与“轮回”，还有现代科学意义上的“熵增”，甚至惊天动地的“宇宙真理”。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de029edea496bca6d3cee6aa7e0c1cad.jpeg" alt="图-圆环之理"></p>
<p>按照热力学第二定律，时间的前进是一种熵增的过程，如果宇宙是一个封闭的空间，那么随着时间的推移，“熵”，即混乱度会随着时间的推进而增大。就比如随着时间的进行，伽利略卫星可能破碎然后变成杂乱的木星环…</p>
<p>宇宙的未来似乎就是这样了，即所谓“热寂”，“故事的结局不是火，而是冰。”</p>
<p>但衔尾蛇为我们指出了世界的另一种可能——从无序到有序，衔尾蛇头尾循环，它的运行不曾有终点，只要时间足够，衔尾蛇就能回到先前的任一状态。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9fa4548dfa750237dced83a1b2a7c09b.jpeg" alt="衔尾蛇"></p>
<p>这不是胡话，试想一下，你拿起一瓶矿泉水扔向空中，总有或多或少的时候水瓶会直接立在地上。那么对无数瓶矿泉水进行这样的操作，总有或多或少的机会让所有水瓶经过抛掷后稳稳立在地上，就好像它们从来没被动过。</p>
<p>同样的，如果让10个数字不停的随机变化，经过足够长的时间后，总会有这10个数分别排列成1到10。</p>
<p>由此我们甚至可以粗略地说：如果一件事有可能发生，那么他就一定能发生。</p>
<h1 id="猴子排序算法"><a href="#猴子排序算法" class="headerlink" title="猴子排序算法"></a>猴子排序算法</h1><p>这个算法原自埃米尔·博雷尔在1909年出版的《为未来竞争》一书中提到的“无限猴子定理“（又一说为出自安德雷·柯尔莫哥洛夫在1933年出版的《概率论》中的”零一律“）。该定理内容大致为：给一只猴子一台打印机，虽然这只猴子根本不识字，但会乱按，经过一段时间后，在它乱按出来的单词里总能找到一些至少看起来是有意义的部分，比如一两个简短的单词，由此可以推出：只要给它足够长的时间，猴子甚至能完整地写出一本莎士比亚全集。</p>
<p>所以，以无限猴子理论为基础的猴子算法的实质就是…乱排！</p>
<p>没错，就是纯粹的乱弄，只有当瞎猫撞见死耗子了才能排序成功。</p>
<p>下面我们来试着实现以下…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp,index,buffer,mark,numbuffer[DATA_AMOUNT];</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 乱序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = RANDOM(<span class="number">0</span>, DATA_AMOUNT - <span class="number">1</span>);</span><br><span class="line">            temp = nums[index];</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查</span></span><br><span class="line">        mark = <span class="number">0</span>;</span><br><span class="line">        buffer = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>]) mark = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!mark) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANDOM(N,M) (rand() %((M)-(N)+1)+(N))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_AMOUNT 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALGORITHM_NAME <span class="string">&quot;猴子排序&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[DATA_AMOUNT];</span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++) nums[i] = RANDOM(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> start,end;</span><br><span class="line">    start = clock();</span><br><span class="line">    algorithm();</span><br><span class="line">    end = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;algorithm \&quot;%s\&quot; used %f sec to process %d data\n&quot;</span>,ALGORITHM_NAME,(<span class="type">float</span>)(end - start)/CLOCKS_PER_SEC,DATA_AMOUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FAILED&quot;</span>);</span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;PASSED&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp,index,buffer,mark,numbuffer[DATA_AMOUNT];</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 乱序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            index = RANDOM(<span class="number">0</span>, DATA_AMOUNT - <span class="number">1</span>);</span><br><span class="line">            temp = nums[index];</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查</span></span><br><span class="line">        mark = <span class="number">0</span>;</span><br><span class="line">        buffer = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; DATA_AMOUNT - <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>]) mark = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!mark) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你别不信，这鬼算法真的能用：<br><img src="https://img-blog.csdnimg.cn/img_convert/8462ddc89f2d4b33af6821862d144846.png" alt="pkE6Y.png"></p>
<h1 id="猴子算法的存在意义"><a href="#猴子算法的存在意义" class="headerlink" title="猴子算法的存在意义"></a>猴子算法的存在意义</h1><p>如你所见，猴子算法是一种非常看脸的算法，在<strong>最理想的条件下</strong>，猴子算法甚至能瞬间完成排序。但更多的时候，猴子算法的耗时趋近于无穷大。</p>
<p>猴子算法的意义更多的是理论上的而非应用上，它打破了排序算法时间复杂度的极限，在<strong>理想条件下</strong>猴子算法的时间复杂度甚至是$O(1)$，尽管这个常数通常会大得离谱。</p>
<hr>
<p><div id="refer-id">参考或引用</div><br>[1] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A1%94%E5%B0%BE%E8%9B%87/2609957">https://baike.baidu.com/item/%E8%A1%94%E5%B0%BE%E8%9B%87/2609957</a> <br>&lt;/br&gt;<br>[2] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%97%A0%E9%99%90%E7%8C%B4%E5%AD%90%E5%AE%9A%E7%90%86/2221476">https://baike.baidu.com/item/%E6%97%A0%E9%99%90%E7%8C%B4%E5%AD%90%E5%AE%9A%E7%90%86/2221476</a><br></br><br>[3] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%86%E7%8E%AF%E4%B9%8B%E7%90%86/2698298">https://baike.baidu.com/item/%E5%9C%86%E7%8E%AF%E4%B9%8B%E7%90%86/2698298</a><br></br><br>[4] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/216250712">https://zhuanlan.zhihu.com/p/216250712</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/04/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/04/%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">记忆化递归和动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-04 16:33:32 / 修改时间：16:34:29" itemprop="dateCreated datePublished" datetime="2022-10-04T16:33:32+08:00">2022-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我是想记录一下<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">这道题</a>。</p>
<h1 id="爬楼梯问题的递归解法"><a href="#爬楼梯问题的递归解法" class="headerlink" title="爬楼梯问题的递归解法"></a>爬楼梯问题的递归解法</h1><p>原题是这样的：</p>
<blockquote>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<p>很容易想到这样的树状图结构：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAoMuR"><img src="https://img-blog.csdnimg.cn/img_convert/40cc5d547695b6af0177f279302004d0.png" alt="xAoMuR.png"></a></p>
<p>利用递归算法进行实现应该是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归入口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>) + <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看似天衣无缝，然而…</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xA5fzj"><img src="https://img-blog.csdnimg.cn/img_convert/dece0e8f4c2c0caa77ddf41a290c4ea2.png" alt="xA5fzj.png"></a></p>
<p>其实仔细观察上述树状图，不难发现该算法的时间复杂度是$O(2^n)$，每一层递归的复杂度是上一层的两倍，这样的效率可以说是糟糕的了。</p>
<p>有没有方法可以优化这样的递归？</p>
<h1 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h1><p>”记忆化递归“，这个算法有很多名字，比如“递归树的剪枝”，“备忘录递归”…… 其核心思想就是去除递归过程中不必要的重复计算，以提高算法的效率。</p>
<p>那么我们要去除的”不必要的重复计算“在哪里呢，请看：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAolHx"><img src="https://img-blog.csdnimg.cn/img_convert/ac22a313c6ec2c7b4517d105e98109ea.png" alt="xAolHx.png"></a></p>
<p>以同一数字展开的树状图当然是一样的，如果我们能够保存第一次计算时的结果，在以后遇到同样数字时直接使用先前计算得到的结果，就能给树状图”剪枝”，也就能消除“不必要的重复“了。</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xAo3E6"><img src="https://img-blog.csdnimg.cn/img_convert/9e31647e74a390e3d554e0099e5533d4.png" alt="xAo3E6.png"></a></p>
<p>上述思路中，我们实际上需要储存的是树状图中的被展开数与其最终结果之间的关系，也就是键值对，那么哈希表就是最好的选择。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = umap.<span class="built_in">find</span>(n);</span><br><span class="line"><span class="keyword">if</span>(item != umap.<span class="built_in">end</span>()) <span class="keyword">return</span> item-&gt;second;</span><br></pre></td></tr></table></figure>
<p>稍微写一个类似单元测试的框架，整体的代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间优化，查询并尝试利用之前已经计算过的爬n个楼梯的方法数</span></span><br><span class="line">        <span class="keyword">auto</span> item = umap.<span class="built_in">find</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(item != umap.<span class="built_in">end</span>()) <span class="keyword">return</span> item-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归入口，集成了时间优化的记录</span></span><br><span class="line">        <span class="keyword">auto</span> buffer = <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 时间优化，记录当前计算的爬楼梯数n与其方法数的对应关系到哈希表</span></span><br><span class="line">        umap.<span class="built_in">insert</span>(&#123; n, buffer &#125;);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Solution s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">climbStairs</span>(n) == target; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, 2&gt;, 7&gt; tests&#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">8</span>, <span class="number">34</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : tests)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">test</span>(item.<span class="built_in">at</span>(<span class="number">0</span>), item.<span class="built_in">at</span>(<span class="number">1</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;failed on test(&quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&quot;),it should be &quot;</span> &lt;&lt; item.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;,but actually &quot;</span> &lt;&lt; s.<span class="built_in">climbStairs</span>(item.<span class="built_in">at</span>(<span class="number">0</span>)) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;PASSED\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时代码已经能够在力扣上通过，本地Linux上测试的结果表明，当n=45时，记忆化递归平均用时0.0016s，而原始递归平均耗时为4.618s，仅仅几行代码将效率提升了接近3000倍。</p>
<p>但是这样的提升也不是毫无代价的，为了实现记忆化，我们使用了一个哈希表，而哈希表恰好就是个拿空间换时间的主，难以避免的，记忆化递归也是在用空间换取时间。不过在大多数情况下，和节省的时间相比，多耗费的那点内存根本不值一提。</p>
<p><del>后记：本来想拓展到动态规划的，但是好像超出我目前的能力范围了，等我学会了再写吧。</del></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AB4y1w7eT">https://www.bilibili.com/video/BV1AB4y1w7eT</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/">猿来绘-爬楼梯的正确姿势（拥抱递归）-70. 爬楼梯 - 爬楼梯 - 力扣（LeetCode）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming—从菜鸟到老鸟<em>HankingHu的博客-CSDN博客</em>动态规划</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/10/04/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/04/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">快慢指针算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-04 15:34:22 / 修改时间：15:36:13" itemprop="dateCreated datePublished" datetime="2022-10-04T15:34:22+08:00">2022-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>平衡二叉树好像有点难，我来写个简单的摸摸鱼（</del></p>
<h1 id="环形链表问题"><a href="#环形链表问题" class="headerlink" title="环形链表问题"></a>环形链表问题</h1><p>Leetcode上有<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">这样一道题</a></p>
<blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<p>只让判断是否有环，非常简单，根据之前的备忘录算法我很快写出了这串代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        std::unordered_map&lt;ListNode*,<span class="type">int</span>&gt; mem;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mem.<span class="built_in">find</span>(head) != mem.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            mem.<span class="built_in">insert</span>(std::<span class="built_in">pair</span>&lt;ListNode*,<span class="type">int</span>&gt;(head,head-&gt;val));</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非常优雅，但…</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3a34"><img src="https://img-blog.csdnimg.cn/img_convert/7f642122d7d69074c1dd06b38808ec0b.png" alt="xm3a34.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3YNT"><img src="https://img-blog.csdnimg.cn/img_convert/21dce248550383629dec746fd4e85b52.png" alt="xm3YNT.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3t4U"><img src="https://img-blog.csdnimg.cn/img_convert/19e547f9277c6e709f61091767fc9e41.png" alt="xm3t4U.png"></a></p>
<p>可以说是惨不忍睹了，虽知哈希表以空间换时间，但全盘皆输，着实令人大跌眼镜。</p>
<h2 id="快慢指针算法"><a href="#快慢指针算法" class="headerlink" title="快慢指针算法"></a>快慢指针算法</h2><p>又叫Floyd判圈法（弗洛伊德判圈法），简单地说就是在表的头部放置两个前进速度不同的指针，使他们同时出发，如果该表不是线性表，则前进速度快的指针会率先进入”循环圈“，慢指针紧随其后，使快指针追击慢指针。由于有速度差异，只要该”循环圈“存在，快指针在”循环圈“内运行若干周期后，总会追上慢指针，所以只要指针和慢指针相遇，我们就能认定该链表是环形链表。</p>
<p>基于以上理解，我们可以写出如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">2</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">2</span>;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --count;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(slow == head) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>效果立竿见影</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xm3UCF"><img src="https://img-blog.csdnimg.cn/img_convert/ac1ad8672de95b6f019aebdc264b0667.png" alt="xm3UCF.png"></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IAKSH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/IAKSH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IAKSH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:askzrj21@163.com" title="E-Mail → mailto:askzrj21@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IAKSH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
