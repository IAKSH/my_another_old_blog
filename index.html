<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"iaksh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hello world!">
<meta property="og:url" content="https://iaksh.github.io/index.html">
<meta property="og:site_name" content="Hello world!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="IAKSH">
<meta property="article:tag" content="IAKSH">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://iaksh.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hello world!</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hello world!</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/29/C%E8%AF%AD%E8%A8%80%E4%B8%ADpthread%E6%88%96Windows-API%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/C%E8%AF%AD%E8%A8%80%E4%B8%ADpthread%E6%88%96Windows-API%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">C语言中pthread或Windows API在多线程编程中的基本应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-29 02:29:37 / 修改时间：02:37:20" itemprop="dateCreated datePublished" datetime="2022-08-29T02:29:37+08:00">2022-08-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>警告</p>
<ol>
<li><p>由于我懒得写完，而且懂的也不是很多，本文不会深入各个多线程库，不会涉及具体的高并发，原子操作等复杂内容，本文仅描述了C语言中多线程技术的基本使用方法<del>，适合新人。</del></p>
</li>
<li><p>由于threads.h与pthread.h定位冲突且资料较少，我没有对thread.h深究，仅仅列出部分宏&#x2F;函数表</p>
</li>
<li><p>实际上posix环境下的多线程库（还有C++的threads）都大差不差，思路都是互通的，只有Windows是个异类，所以本文重心在于pthread和Windows API的CreateThread。</p>
</li>
<li><p>阅读本文需要一定的基础。</p>
</li>
</ol>
<h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><p>现代操作系统通常以进程（process）作为CPU资源调度的最小单位，其实际上是线程的容器，而线程则是程序指令以及其资源的容器，从这样的角度，我们可以这样说：线程即是“程序”。</p>
<ul>
<li>我们为什么要使用多线程？</li>
</ul>
<p>原因是多种多样的，扯远一点，由于摩尔定律的失效（CPU单核性能在短期内无法取得决定性的进步），红蓝两家都在往CPU上堆核心，广大程序员无法享用单核红利。而着眼于手边，你可能会为了实现一个好看的读条界面而转向超线程，或者可能是为了在读取文件的同时输出日志，或者仅仅是想给自己的CPU来一次压力测试…</p>
<ul>
<li>如何获得多核红利？</li>
</ul>
<p>高效利用你的CPU核心的方式多种多样，其中最朴实无华（但实际上也能复杂得让人头痛）的便是多线程技术。ISO C 11提供了一个标准库头文件threads.h以提供多线程功能（但截至目前，Visual Studio未提供相应实现），在posix环境中也可以使用pthread.h，对于Windows环境，也能使用Windows API来管理线程。</p>
<h1 id="掌握多线程需要学习什么？"><a href="#掌握多线程需要学习什么？" class="headerlink" title="掌握多线程需要学习什么？"></a>掌握多线程需要学习什么？</h1><ol>
<li><p>学会创建一个线程</p>
</li>
<li><p>学会管理线程</p>
</li>
<li><p>学会使用互斥锁缓解线程安全问题</p>
</li>
<li><p>…</p>
</li>
</ol>
<p>实际上，多线程是一个大坑，非常坑，远远不止上述内容。</p>
<p>如果要深究，还得涉及到操作系统层面的调度，甚至是硬件层面的乱序发射。</p>
<h1 id="使用pthread-h实现多线程"><a href="#使用pthread-h实现多线程" class="headerlink" title="使用pthread.h实现多线程"></a>使用pthread.h实现多线程</h1><p>使用pthread需要链接pthread.so（或windows上的libwinpthread），mingw-w64 gcc若使用posix线程模型则默认链接该库，而linux上的gcc则需要手动配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动编译示例</span></span><br><span class="line">gcc main.c -o app -lpthread</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake示例</span></span><br><span class="line"><span class="keyword">add_executable</span>(learning_pthread)</span><br><span class="line"><span class="keyword">target_sources</span>(learning_pthread PUBLIC main.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(learning_pthread PUBLIC pthread)</span><br></pre></td></tr></table></figure>

<p>pthread.h的内容几乎都以pthread_开头，请看如下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">say</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    <span class="type">pthread_t</span> t2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原型为 pthread_create(pthread_t *restrict newthread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg)</span></span><br><span class="line">    <span class="comment">// 此处第四个参数进行了隐式转换</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, say, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, say, <span class="string">&quot;pthread is awesome!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非阻塞</span></span><br><span class="line">    pthread_detach(t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞当前线程，可以指定返回值到何处，但此处不需要，故设为NULL</span></span><br><span class="line">    pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) <span class="built_in">puts</span>(<span class="string">&quot;if you see this , the main thread is still alive!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，你可以使用如下函数强行终止一个线程</span></span><br><span class="line"><span class="comment">//void  pthread_exit（void  *retval）;</span></span><br><span class="line"><span class="comment">// 你还可以使用下述函数获得当前线程标识</span></span><br><span class="line"><span class="comment">//pthread_t pthread_self(void);</span></span><br></pre></td></tr></table></figure>

<p>编译并运行上述代码，你应该能发现“hello world”和“pthread is awesome”交替输出，但是一者输出一段时间后换为另一者进行输出，这是因为每个线程都分配到了一定的CPU时间片，当自己的时间片用尽时才会让出CPU，让其他线程执行，线程其实并没有同步执行，只是高速切换。</p>
<p>最后的“if you see this , the main thread is still alive!”是不会被输出的，因为主线程执行到“pthread_join(t2,NULL);”时就被堵塞了。</p>
<p>pthread中也提供了互斥锁以<strong>缓解</strong>线程安全问题，和其他的多线程库一样，其操作总结下来无非就是</p>
<ol>
<li><p>创建mutex</p>
</li>
<li><p>对关键IO操作上锁</p>
</li>
<li><p>完成关键IO操作后解锁</p>
</li>
</ol>
<p>放到代码中就像是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mut;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counter</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10000</span> / <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对非本线程资源的读写，可能存在冲突，故上锁</span></span><br><span class="line">		pthread_mutex_lock(&amp;mut);</span><br><span class="line">		g_number++;</span><br><span class="line">		pthread_mutex_unlock(&amp;mut);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种直接上锁的方式尽管简单易用，但却实际上使程序的IO部分退化回了单线程，造成了一定的性能损失。而想要解决这个问题，我们就得来谈谈“原子操作”了。</p>
<p>原子操作是一种复杂且经过数次迭代的机制，简单来说，它是一个不可中断的，一系列的操作，它不会被线程调度机制打断，也不会有任何的上下文切换。使用原子操作，能完美解决传统mutex锁策略所带来的性能损失，同时保证线程安全。</p>
<p>你可能好奇如此神奇的机制到底是如何实现的，其实，时至今日，原子操作早已不单是标准库中的一套概念，而是整合进了CPU的一套指令集。原子操作的底层是由CPU硬件实现的。</p>
<p>在ISO C 11中标准库提供了stdatomic.h，我们可以用它来实现原子操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码截取自zh.cppreference.com</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">atomic_int</span> acnt;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>* thr_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ++acnt;</span><br><span class="line">        <span class="comment">// 对于此例，宽松内存顺序是足够的，例如</span></span><br><span class="line">        <span class="comment">// atomic_fetch_add_explicit(&amp;acnt, 1, memory_order_relaxed);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">thrd_t</span> thr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_create(&amp;thr[n], f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_join(thr[n], <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The atomic counter is %u\n&quot;</span>, acnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The non-atomic counter is %u\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Windows-API实现多线程"><a href="#使用Windows-API实现多线程" class="headerlink" title="使用Windows API实现多线程"></a>使用Windows API实现多线程</h1><p>其实在我看来，使用Windows API是迫不得已的下下策，但无可否认的是，如此的”迫不得已“，实在是太普遍了。</p>
<p>Windows API有个特色，就是参数列表又臭又长，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">                    LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span><br><span class="line"><span class="params">                    DWORD dwStackSize,</span></span><br><span class="line"><span class="params">                    LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">                    LPVOID lpParameter,</span></span><br><span class="line"><span class="params">                    DWORD dwCreationFlags,</span></span><br><span class="line"><span class="params">                    LPDWORD lpThreadID</span></span><br><span class="line"><span class="params">                   )</span>;</span><br><span class="line"><span class="comment">// 其实这还不是最长的（小声</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lpThreadAttrivutes</td>
<td>用于定义新线程的安全属性，一般为NULL</td>
</tr>
<tr>
<td>dwStackSize</td>
<td>线程堆栈的大小，单位字节，默认为0</td>
</tr>
<tr>
<td>lpStartAddress</td>
<td>线程函数地址，即此线程需要执行的函数</td>
</tr>
<tr>
<td>lpParameter</td>
<td>传给线程函数的参数</td>
</tr>
<tr>
<td>dwCreationFlags</td>
<td>创建线程的运行状态，CREATE_SUSPEND表示挂起，0表示立即执行</td>
</tr>
<tr>
<td>lpThreadID</td>
<td>回新创建的线程的ID</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待线程结束，其实也可以是等待其他东西</span></span><br><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">                          HANDLE hHandle,</span></span><br><span class="line"><span class="params">                          DWORD dwMilliseconds</span></span><br><span class="line"><span class="params">                         )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hHandle</td>
<td>对象或时间的句柄</td>
</tr>
<tr>
<td>dwMilliseconds</td>
<td>最长等待时间，单位毫秒，若超过此最长时间则强制返回，亦可设为INFINITE，然后等待戈多（不</td>
</tr>
</tbody></table>
<p>Windows API也提供了与mutex锁类似的机制来缓解线程安全问题，叫”临界区“</p>
<p>其使用步骤大体为：</p>
<ol>
<li><p>创建临界区： CRITICAL_SECTION cs</p>
</li>
<li><p>初始化临界区：InitializeCriticalSection(&amp;cs)</p>
</li>
<li><p>在关键IO前进入临界区：EnterCriticalSection(&amp;cs);</p>
</li>
<li><p>关键IO结束后退出临界区：LeaveCriticalSection(&amp;cs);</p>
</li>
</ol>
<p>下面是一端演示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">func</span><span class="params">(LPVOID parament)</span></span><br><span class="line">&#123;</span><br><span class="line">    EnterCriticalSection(&amp;cs);</span><br><span class="line">    <span class="comment">// certain IO</span></span><br><span class="line">    i++;</span><br><span class="line">    LeaveCriticalSection(&amp;cs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE thread[<span class="number">2</span>];</span><br><span class="line">    DWORD ret1;</span><br><span class="line">    DWORD ret2;</span><br><span class="line"></span><br><span class="line">    InitializeCriticalSection(&amp;cs);</span><br><span class="line">    <span class="comment">// 两个线程都设置为立即执行，从效果上说和pthread_detach类似</span></span><br><span class="line">    thread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, func, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    thread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, func, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    WaitForMultipleObjects(<span class="number">2</span>, thread, TRUE, INFINITE);</span><br><span class="line">    CloseHandle(harrThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(harrThread[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用threads-h实现多线程"><a href="#使用threads-h实现多线程" class="headerlink" title="使用threads.h实现多线程"></a>使用threads.h实现多线程</h1><p>thread.h在ISO C 11标准后加入，请确保你的编译器支持且启用了ISO C 11标准。另外，Visual Studio尚未支持ISO C 11的threads.h，因为他们从来不关心C语言标准。</p>
<p>threads.h的函数均以thrd_开头，常用内容如下</p>
<table>
<thead>
<tr>
<th>标识符&#x2F;原型</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>thrd_t</td>
<td>宏</td>
<td>用于存放线程的相关数据，可以当成线程对象来使用</td>
</tr>
<tr>
<td>int thrd_create(thrd_t *thr, thrd_start_t func, void *arg);</td>
<td>函数</td>
<td>创建线程并指定其执行的函数</td>
</tr>
<tr>
<td>int thrd_detach(thrd_t thr);</td>
<td>函数</td>
<td>将子线程与主线程分离，使其与主线程并行</td>
</tr>
<tr>
<td>int thrd_equal(thrd_t thr0, thrd_t thr1);</td>
<td>函数</td>
<td>判断两个线程标识符是否标识同一线程</td>
</tr>
<tr>
<td>void thrd_exit(int res)</td>
<td>函数</td>
<td>强制结束某线程</td>
</tr>
<tr>
<td>int thrd_join(thrd_t thr, int *res)</td>
<td>函数</td>
<td>注意：我查到的资料中的描述和我实际测试的结果不同，我现有的资料都说此函数会阻塞当前线程，但实际测试结果并未阻塞，存疑。</td>
</tr>
<tr>
<td>void thrd_sleep(const xtime *xt)</td>
<td>函数</td>
<td>使当前线程休眠指定时间</td>
</tr>
<tr>
<td>void thrd_yield(void)</td>
<td>函数</td>
<td>挂起当前线程，让出CPU资源</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>(不分先后，随机排序)</p>
<p><a target="_blank" rel="noopener" href="https://www.ibadboy.net/archives/2323.html">C11新增多线程支持库-threads.h参考手册 – 坏蛋的博客 (ibadboy.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42055033/article/details/106560321">windows API（9）线程安全 临界区_飘零的落花的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012877472/article/details/49721653">使用CreateThread函数创建线程_Valineliu的博客-CSDN博客_createthread函数</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97418361">C语言多线程编程(一) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/c/language/atomic">原子类型 - cppreference.com</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/1880992">原子操作_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuiyunzhugang/article/details/108147466">什么是原子操作_辽宁大学的博客-CSDN博客_原子操作</a></p>
<p>[多核，并行计算和摩尔定律浅谈_DrPerformance的博客-CSDN博客</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/23/EasyX%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/EasyX%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">EasyX基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-23 15:05:18 / 修改时间：15:07:39" itemprop="dateCreated datePublished" datetime="2022-08-23T15:05:18+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EasyX"><a href="#EasyX" class="headerlink" title="EasyX"></a>EasyX</h1><blockquote>
<p>EasyX Graphics Library 是针对 Visual C++ 的免费绘图库，支持 VC6.0 ~ VC2022，简单易用，学习成本极低，应用领域广泛。目前已有许多大学将 EasyX 应用在教学当中。</p>
</blockquote>
<ol>
<li><p>EasyX其实是一个C++库，不是C库，这就像VC只有C++编译器，没有C编译器一样。</p>
</li>
<li><p>EasyX最初发布于2009年，其底层是gdi，设计上和Windows API高度耦合，但在使用上基本不用了解太多的Windows API。EasyX是一个图形库，或者说只是一个绘图库，因为它相较于OpenGL以及其他的如SDL2的库而言只有一个优势——简单易用。它能让新人快速上手，了解以及学习绘图算法。</p>
</li>
<li><p>如果你是一位新人，那么EasyX对你最大的吸引力大概在于：只用学习少量内容，就能暂时摆脱烦人的黑框框程序，窥得一眼五彩斑斓的GUI世界。</p>
</li>
<li><p>EasyX能干什么？EasyX可以绘图，这意味着它能实现一些图像处理功能，或者是一个游戏，一个数据分析软件，一个动画合成软件，等等等等，但需要明确的是，上述内容都不是单单一个EasyX就能完成的。</p>
</li>
</ol>
<h1 id="搭建EasyX的开发环境"><a href="#搭建EasyX的开发环境" class="headerlink" title="搭建EasyX的开发环境"></a>搭建EasyX的开发环境</h1><ol>
<li><p>由于与Windows API高度耦合，EasyX官方仅支持VC工具链，具体版本下至Visual C++ 6.0，上至Visual Studio 2022。（截至目前而言）</p>
</li>
<li><p>官方提供了一个<a target="_blank" rel="noopener" href="https://easyx.cn/download/EasyX_20220610.exe">安装程序</a>来完成各个版本VC&#x2F;VS上的一键式部署与卸载。（同时也提供了一个离线文档）</p>
</li>
</ol>
<h1 id="使用EasyX编写GUI程序的简单示例"><a href="#使用EasyX编写GUI程序的简单示例" class="headerlink" title="使用EasyX编写GUI程序的简单示例"></a>使用EasyX编写GUI程序的简单示例</h1><ol>
<li>引入EasyX库的头文件，旧版本的EasyX使用graphics.h（这也是你在网上能找到的大多数教程所用的头文件），但现在应该使用easyx.h。目前的graphics.h仅保留了若干已被easyx.h废弃的旧版功能。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>初始化绘图窗口，创建一个指定大小（此处示例为640x480像素）的窗口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>绘图，此处示例为绘制一个圆心为（200,200），半径为100的圆。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">circle</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关闭绘图窗口</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">closegraph</span>();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>完整代码</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">    <span class="built_in">circle</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">    _getch();</span><br><span class="line">    <span class="built_in">closegraph</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行效果</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/v6xQHI"><img src="https://s1.ax1x.com/2022/08/23/v6xQHI.png" alt="v6xQHI.png"></a></p>
<hr>
<h1 id="EasyX中的基本概念"><a href="#EasyX中的基本概念" class="headerlink" title="EasyX中的基本概念"></a>EasyX中的基本概念</h1><h2 id="EaysX中颜色的三种表示方式："><a href="#EaysX中颜色的三种表示方式：" class="headerlink" title="EaysX中颜色的三种表示方式："></a>EaysX中颜色的三种表示方式：</h2><ol>
<li><p>宏定义：EasyX内建了一些宏常量来表示颜色</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>值</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td>BLACK</td>
<td>0</td>
<td>黑</td>
</tr>
<tr>
<td>BLUE</td>
<td>0xAA0000</td>
<td>蓝</td>
</tr>
<tr>
<td>GREEN</td>
<td>0x00AA00</td>
<td>绿</td>
</tr>
<tr>
<td>CYAN</td>
<td>0xAAAA00</td>
<td>青</td>
</tr>
<tr>
<td>RED</td>
<td>0x0000AA</td>
<td>红</td>
</tr>
<tr>
<td>MAGENTA</td>
<td>0xAA00AA</td>
<td>紫</td>
</tr>
<tr>
<td>BROWN</td>
<td>0x0055AA</td>
<td>棕</td>
</tr>
<tr>
<td>LIGHTGRAY</td>
<td>0xAAAAAA</td>
<td>浅灰</td>
</tr>
<tr>
<td>DARKGRAY</td>
<td>0x555555</td>
<td>深灰</td>
</tr>
<tr>
<td>LIGHTBLUE</td>
<td>0xFF5555</td>
<td>亮蓝</td>
</tr>
<tr>
<td>LIGHTGREEN</td>
<td>0x55FF55</td>
<td>亮绿</td>
</tr>
<tr>
<td>LIGHTCYAN</td>
<td>0xFFFF55</td>
<td>亮青</td>
</tr>
<tr>
<td>LIGHTRED</td>
<td>0x5555FF</td>
<td>亮红</td>
</tr>
<tr>
<td>LIGHTMAGENTA</td>
<td>0xFF55FF</td>
<td>亮紫</td>
</tr>
<tr>
<td>YELLOW</td>
<td>0x55FFFF</td>
<td>黄</td>
</tr>
<tr>
<td>WHITE</td>
<td>0xFFFFFF</td>
<td>白</td>
</tr>
</tbody></table>
</li>
<li><p>16进制：</p>
<p>格式为0xbbggrr（bb&#x3D;蓝，gg&#x3D;绿，rr&#x3D;红）</p>
</li>
<li><p>RGB宏：用于将红、绿、蓝颜色分量合成RGB颜色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">RGB</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byRed,        <span class="comment">// 颜色的红色部分，取值范围：0~255，下同</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byGreen,    <span class="comment">// 颜色的绿色部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE byBlue        <span class="comment">// 颜色的蓝色部分</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HSLtoRGB，HSVtoRGB：用于将HSL&#x2F;HSV颜色空间模型转至RGB。</p>
</li>
</ol>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><ol>
<li><p>物理坐标：描述设备的坐标体系，以设备左上角为原点，X轴向右为正，Y轴向下为负，度量单位为像素，不可缩放。</p>
</li>
<li><p>逻辑坐标：程序中用于绘图的坐标体系，以窗口左上角为原点，X轴向右为正，Y轴向下为正，度量单位为点。在默认情况下，逻辑坐标与物理坐标一一对应，一个逻辑点即为一个物理像素。</p>
</li>
</ol>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><ol>
<li><p>“设备”指的是绘图表面。（根据功能，可以粗略理解为画板，但是其实并不仅仅是画板）</p>
</li>
<li><p>EasyX中有两种设备：默认的绘图窗口以及IMAGE对象，使用函数SetWorkingImag可更改当前用于绘图的设备，所以的绘图函数都将图形绘制在该设备上。</p>
</li>
</ol>
<hr>
<h1 id="EasyX部分功能示例"><a href="#EasyX部分功能示例" class="headerlink" title="EasyX部分功能示例"></a>EasyX部分功能示例</h1><p>只列出了我认为最有用的部分</p>
<h2 id="清屏：cleardevice"><a href="#清屏：cleardevice" class="headerlink" title="清屏：cleardevice"></a>清屏：cleardevice</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleardevice</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="设置当前设备绘图背景色：setbkcolor"><a href="#设置当前设备绘图背景色：setbkcolor" class="headerlink" title="设置当前设备绘图背景色：setbkcolor"></a>设置当前设备绘图背景色：setbkcolor</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbkcolor</span><span class="params">(COLORREF color)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="设置当前设备图案填充和文字输出时的背景模式"><a href="#设置当前设备图案填充和文字输出时的背景模式" class="headerlink" title="设置当前设备图案填充和文字输出时的背景模式"></a>设置当前设备图案填充和文字输出时的背景模式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbkmode</span><span class="params">(<span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>mode参数的各个值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OPAQUE</td>
<td>背景用当前背景色填充（默认）</td>
</tr>
<tr>
<td>TRANSPARENT</td>
<td>背景透明</td>
</tr>
</tbody></table>
<h2 id="设置当前设备填充样式：setfillstyle"><a href="#设置当前设备填充样式：setfillstyle" class="headerlink" title="设置当前设备填充样式：setfillstyle"></a>设置当前设备填充样式：setfillstyle</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FILLSTYLE* pstyle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> style,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">long</span> hatch = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    IMAGE* ppattern = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setfillstyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BYTE* ppattern8x8</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pstyle</td>
<td>指向填充样式 FILLSTYLE 的指针</td>
</tr>
<tr>
<td>style</td>
<td>指定填充样式</td>
</tr>
<tr>
<td>hatch</td>
<td>指定填充图案</td>
</tr>
</tbody></table>
<p>具体内容请参照[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setfillstyle">EasyX 文档 - setfillstyle</a>)</p>
<h2 id="设置当前设备画线样式：setlinestyle"><a href="#设置当前设备画线样式：setlinestyle" class="headerlink" title="设置当前设备画线样式：setlinestyle"></a>设置当前设备画线样式：setlinestyle</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setlinestyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> LINESTYLE* pstyle</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setlinestyle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> style,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> DWORD *puserstyle = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD userstylecount = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pstyle</td>
<td>指向画线样式 LINESTYLE 的指针</td>
</tr>
<tr>
<td>style</td>
<td>画线样式</td>
</tr>
<tr>
<td>thickness</td>
<td>线的宽度（单位为像素）</td>
</tr>
<tr>
<td>puserstyle</td>
<td>用户自定义样式数组</td>
</tr>
<tr>
<td>userstylecount</td>
<td>用户自定义样式数组的元素数量。</td>
</tr>
</tbody></table>
<p>具体内容请参照[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setlinestyle">EasyX 文档 - setlinestyle</a>)</p>
<h2 id="设置当前设备多边形填充模式：setpolyfillmode"><a href="#设置当前设备多边形填充模式：setpolyfillmode" class="headerlink" title="设置当前设备多边形填充模式：setpolyfillmode"></a>设置当前设备多边形填充模式：setpolyfillmode</h2><table>
<thead>
<tr>
<th>mode的各个值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALTERNATE</td>
<td>交替填充模式（默认值）</td>
</tr>
<tr>
<td>WINDING</td>
<td>根据绘图方向填充的模式</td>
</tr>
</tbody></table>
<p>详见[官方文档](<a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/setpolyfillmode">EasyX 文档 - setpolyfillmode</a>)</p>
<hr>
<h1 id="EasyX的部分函数文档索引"><a href="#EasyX的部分函数文档索引" class="headerlink" title="EasyX的部分函数文档索引"></a>EasyX的部分函数文档索引</h1><p>这里其实就是官方文档的内容，只是给大家引个路。</p>
<h2 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/arc">arc</a></td>
<td>画椭圆弧。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/circle">circle</a></td>
<td>画无填充的圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearcircle">clearcircle</a></td>
<td>清空圆形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearellipse">clearellipse</a></td>
<td>清空椭圆区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearpie">clearpie</a></td>
<td>清空扇形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearpolygon">clearpolygon</a></td>
<td>清空多边形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearrectangle">clearrectangle</a></td>
<td>清空矩形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/clearroundrect">clearroundrect</a></td>
<td>清空圆角矩形区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/ellipse">ellipse</a></td>
<td>画无填充的椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillcircle">fillcircle</a></td>
<td>画有边框的填充圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillellipse">fillellipse</a></td>
<td>画有边框的填充椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillpie">fillpie</a></td>
<td>画有边框的填充扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillpolygon">fillpolygon</a></td>
<td>画有边框的填充多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillrectangle">fillrectangle</a></td>
<td>画有边框的填充矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/fillroundrect">fillroundrect</a></td>
<td>画有边框的填充圆角矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/floodfill">floodfill</a></td>
<td>填充区域。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getheight">getheight</a></td>
<td>获取绘图区的高度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getpixel">getpixel</a></td>
<td>获取点的颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getwidth">getwidth</a></td>
<td>获取绘图区的宽度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/line">line</a></td>
<td>画直线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/pie">pie</a></td>
<td>画无填充的扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polybezier">polybezier</a></td>
<td>画三次方贝塞尔曲线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polyline">polyline</a></td>
<td>画多条连续的线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/polygon">polygon</a></td>
<td>画无填充的多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/putpixel">putpixel</a></td>
<td>画点。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/rectangle">rectangle</a></td>
<td>画无填充的矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/roundrect">roundrect</a></td>
<td>画无填充的圆角矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidcircle">solidcircle</a></td>
<td>画无边框的填充圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidellipse">solidellipse</a></td>
<td>画无边框的填充椭圆。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidpie">solidpie</a></td>
<td>画无边框的填充扇形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidpolygon">solidpolygon</a></td>
<td>画无边框的填充多边形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidrectangle">solidrectangle</a></td>
<td>画无边框的填充矩形。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/solidroundrect">solidroundrect</a></td>
<td>画无边框的填充圆角矩形。</td>
</tr>
</tbody></table>
<h2 id="文字输出"><a href="#文字输出" class="headerlink" title="文字输出"></a>文字输出</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/gettextcolor">gettextcolor</a></td>
<td>获取当前文字颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/gettextstyle">gettextstyle</a></td>
<td>获取当前文字样式。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/LOGFONT">LOGFONT</a></td>
<td>文字样式的结构体。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/outtextxy">outtextxy</a></td>
<td>在指定位置输出字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/drawtext">drawtext</a></td>
<td>在指定区域内以指定格式输出字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/settextcolor">settextcolor</a></td>
<td>设置当前文字颜色。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/settextstyle">settextstyle</a></td>
<td>设置当前文字样式。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/textheight">textheight</a></td>
<td>获取字符串实际占用的像素高度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/textwidth">textwidth</a></td>
<td>获取字符串实际占用的像素宽度。</td>
</tr>
</tbody></table>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/IMAGE">IMAGE</a></td>
<td>保存图像的对象。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/loadimage">loadimage</a></td>
<td>读取图片文件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/saveimage">saveimage</a></td>
<td>保存绘图内容至图片文件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getimage">getimage</a></td>
<td>从当前绘图设备中获取图像。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/putimage">putimage</a></td>
<td>在当前绘图设备上绘制指定图像。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetWorkingImage">GetWorkingImage</a></td>
<td>获取指向当前绘图设备的指针。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/rotateimage">rotateimage</a></td>
<td>旋转 IMAGE 中的绘图内容。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/SetWorkingImage">SetWorkingImage</a></td>
<td>设定当前绘图设备。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/Resize">Resize</a></td>
<td>调整指定绘图设备的尺寸。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetImageBuffer">GetImageBuffer</a></td>
<td>获取绘图设备的显示缓冲区指针。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/GetImageHDC">GetImageHDC</a></td>
<td>获取绘图设备句柄。</td>
</tr>
</tbody></table>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><table>
<thead>
<tr>
<th>函数或数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/exmessage">ExMessage</a></td>
<td>消息结构体。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/flushmessage">flushmessage</a></td>
<td>清空消息缓冲区。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/getmessage">getmessage</a></td>
<td>获取一个消息。如果当前消息缓冲区中没有，就一直等待。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/peekmessage">peekmessage</a></td>
<td>获取一个消息，并立即返回。</td>
</tr>
</tbody></table>
<h2 id="连续绘图"><a href="#连续绘图" class="headerlink" title="连续绘图"></a>连续绘图</h2><p>实际上貌似是启用了双缓冲，可以有效解决连续绘图时的闪烁问题，使用如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br><span class="line"><span class="comment">// 绘制你的内容...</span></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br></pre></td></tr></table></figure>

<p>EndBatchDraw会将绘制的内容输出，使用FlushBatchDraw能达到同样效果。</p>
<h2 id="获取窗口句柄"><a href="#获取窗口句柄" class="headerlink" title="获取窗口句柄"></a>获取窗口句柄</h2><p>EasyX提供了GetHWnd函数以获得当前窗口的句柄，由此你可以使用Windows API对窗口进行进一步的操作，原型如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">GetHWnd</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="输入对话框"><a href="#输入对话框" class="headerlink" title="输入对话框"></a>输入对话框</h2><p>EasyX提供了InputBox函数用于以对话框形式获取用户输入，原型如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR    pString,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        nMaxCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pPrompt = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pTitle = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR    pDefault = <span class="literal">NULL</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        width = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>        height = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>    bHideCancelBtn = <span class="literal">true</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="关于使用EasyX构建一个简单的游戏简述"><a href="#关于使用EasyX构建一个简单的游戏简述" class="headerlink" title="关于使用EasyX构建一个简单的游戏简述"></a>关于使用EasyX构建一个简单的游戏简述</h1><ol>
<li><p>EasyX仅仅是一个绘图库，它只能完成图形的绘制以及鼠标信息的捕获任务，要构建一个完整的游戏，所需要的不仅仅是EasyX。</p>
</li>
<li><p>VC&#x2F;VS中提供了conio.h，能实现非阻塞式的键盘监听（非全局）。</p>
</li>
<li><p>Windows API中的mmsystem.h（需要链接winmm.lib）提供了一套简单的音乐播放功能。</p>
</li>
<li><p>如果你的游戏中的对象是动态的（比如数量不确定的敌人），那么你需要用到堆内存分配，以及一些用于管理堆内存的数据结构。</p>
</li>
<li><p>我之前用EasyX写了<a target="_blank" rel="noopener" href="https://github.com/IAKSH/easySnake">一个游戏</a>，有兴趣可以看看，但是代码很乱，因为我懒。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://docs.easyx.cn/zh-cn/intro">EasyX 文档 - 基本说明</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/19/%E5%85%B3%E4%BA%8Emath-h%E7%9A%84%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/%E5%85%B3%E4%BA%8Emath-h%E7%9A%84%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">关于math.h的笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-19 01:21:52 / 修改时间：02:12:27" itemprop="dateCreated datePublished" datetime="2022-08-19T01:21:52+08:00">2022-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>闲话少叙，直接来吧。 </p>
<h1 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h1><p>    math.h作为C标准库的一部分，提供了部分数学运算函数以及数学常量。其中绝大部分函数都只在头文件内完成声明和定义，仅有部分需要链接数学库（linux）。</p>
<p>    math.h中提供的函数的返回类型和参数类型几乎都是double。</p>
<p>    作为标准库的一部分，为了实现兼容，math.h的内容非常复杂，很难一一列举，<strong>我仅仅举出了部分内容</strong>，仅供参考。</p>
<h1 id="宏常量"><a href="#宏常量" class="headerlink" title="宏常量"></a>宏常量</h1><ol>
<li><p>INFINITY : 正无穷，返回一个 float。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_ISOC99</span></span><br><span class="line"><span class="comment">/* IEEE positive infinity.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> INFINITY (__builtin_inff ())</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> INFINITY HUGE_VALF</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NAN ：非数字（Not-A-Number)，返回一个float。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IEEE Not A Number.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> NAN (__builtin_nanf (<span class="string">&quot;&quot;</span>))</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/* This will raise an &quot;invalid&quot; exception outside static initializers,</span></span><br><span class="line"><span class="comment">   but is the best that can be done in ISO C while remaining a</span></span><br><span class="line"><span class="comment">   constant expression.  */</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> NAN (0.0f / 0.0f)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __USE_ISOC99 */</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>   <em>实际上还有很多宏，无法完全列举，请查阅标准库头文件。</em> </p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><ol>
<li><p>float_t : （当前系统）最有效执行 float 运算的类型，宽度至少与 float 一样。</p>
</li>
<li><p>double_t : （当前系统）最有效执行 double 运算的类型，宽度至少与 double 一样。</p>
<p><em>可能存在更多类型定义，具体视实现而定</em></p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li><p>三角函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double acos(double x)</td>
<td>反余弦（x为弧度制，下同）</td>
</tr>
<tr>
<td>double asin(double x)</td>
<td>反正弦</td>
</tr>
<tr>
<td>double atan(double x)</td>
<td>反正切</td>
</tr>
<tr>
<td>double atan2(double y, double x)</td>
<td>y&#x2F;x 的反正切，y 和 x 的符号决定象限</td>
</tr>
<tr>
<td>double cos(double x)</td>
<td>余弦</td>
</tr>
<tr>
<td>double sin(double x)</td>
<td>正弦</td>
</tr>
</tbody></table>
</li>
<li><p>双曲函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double cosh(double x)</td>
<td>双曲余弦</td>
</tr>
<tr>
<td>double sinh(double x)</td>
<td>双曲正弦</td>
</tr>
<tr>
<td>double tanh(double x)</td>
<td>双曲正切</td>
</tr>
</tbody></table>
</li>
<li><p>指数,对数函数</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double exp(double x)</td>
<td>自然数e 的 x 次幂</td>
</tr>
<tr>
<td>double log(double x)</td>
<td>x 的自然对数</td>
</tr>
<tr>
<td>double log10(double x)</td>
<td>x 的常用对数</td>
</tr>
<tr>
<td>double sqrt(double x)</td>
<td>平方根</td>
</tr>
<tr>
<td>double pow(double x, double y)</td>
<td>x 的 y 次幂</td>
</tr>
<tr>
<td>double modf(double x, double *integer)</td>
<td>x 的常用对数</td>
</tr>
<tr>
<td>double log(double x)</td>
<td>x 的自然对数</td>
</tr>
<tr>
<td>double ldexp(double x, int exponent)</td>
<td>x 乘以 2 的 exponent 次幂</td>
</tr>
</tbody></table>
</li>
<li><p>其他</p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>double floor(double x)</td>
<td>小于或等于 x 的最大的整数值。</td>
</tr>
<tr>
<td>double fmod(double x, double y)</td>
<td>x 除以 y 的余数。</td>
</tr>
<tr>
<td>double fabs(double x)</td>
<td>绝对值</td>
</tr>
<tr>
<td>double ceil(double x)</td>
<td>大于或等于 x 的最小的整数值</td>
</tr>
<tr>
<td>double frexp(double x, int *exponent)</td>
<td>把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x &#x3D; mantissa * 2 ^ exponent</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li><p>math.h中进行了庞大的编译器判断，以使用在当前平台速度最快的数据类型。</p>
</li>
<li><p>math.h是十分重要的，它补充了C&#x2F;C++相比于更新的语言在运算符上的不足，并且提供了一套简单易用，且通用，高效的数学运算。</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>glibc标准库头文件</p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/wangdoc-clang-tutorial/docs-lib-math.h.md">标准库 - math.h - 《阮一峰《C 语言教程》》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-math-h.html">C 标准库 – &lt;math.h&gt; | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/math.h/10991856">math.h_百度百科 (baidu.com)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/18/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89-multiple-definition-%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/%E8%AE%B0%E4%B8%80%E6%AC%A1C%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%9A%E9%87%8D%E5%AE%9A%E4%B9%89-multiple-definition-%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">记一次C中全局变量的多重定义(multiple definition)报错</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-18 23:32:54 / 修改时间：23:33:51" itemprop="dateCreated datePublished" datetime="2022-08-18T23:32:54+08:00">2022-08-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="记一次C中全局变量的多重定义-multiple-definition-报错"><a href="#记一次C中全局变量的多重定义-multiple-definition-报错" class="headerlink" title="记一次C中全局变量的多重定义(multiple definition)报错"></a>记一次C中全局变量的多重定义(multiple definition)报错</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我在一个头文件里定义了一个全局bool（stdbool.h里的那个)，然后在两个源文件中include了这个头文件，在编译时gcc报错multiple definition of  ‘（省略）’</p>
<h2 id="修复一个bug，获得更多bug"><a href="#修复一个bug，获得更多bug" class="headerlink" title="修复一个bug，获得更多bug"></a>修复一个bug，获得更多bug</h2><p>由于太久没有温习，我最初尝试给bool值的声明语句添加static。</p>
<p>这确实解决了问题，但是在头文件中用static定义的变量在每次include时会产生不同的对象。每个include此头文件的文件作用域中都会有一个互不干扰的同名变量。</p>
<p>我的这次操作修复了一个bug，产生了更多bug，并导致我进行了长达1分钟的排查。</p>
<h2 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h2><p>不要在头文件里定义全局变量，这是导致多重定义的直接原因。</p>
<p>如果你不得不这么做，请在头文件中使用extern声明变量，随后在某个源文件内声明。</p>
<h2 id="不解"><a href="#不解" class="headerlink" title="不解"></a>不解</h2><p>道理我都明白，但是，为什么已经加了#pragma once，还是多重定义了。<br>且进一步测试表明，#ifndef + #define + #endif也无法解决此问题。</p>
<h2 id="对上述不解的探究"><a href="#对上述不解的探究" class="headerlink" title="对上述不解的探究"></a>对上述不解的探究</h2><p>我使用gcc -E获取了include上述头文件的源码经过预处理后的文本。</p>
<p>然后…然后啥也没看出来。</p>
<p><em>（未完待续）</em><br><em>（也许吧）</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/C%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%97%B6%E5%BF%BD%E7%95%A5%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%9A%E4%BD%99%E7%9A%840/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/C%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E6%97%B6%E5%BF%BD%E7%95%A5%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%9A%E4%BD%99%E7%9A%840/" class="post-title-link" itemprop="url">C中格式化输出时忽略浮点数多余的0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 23:32:02 / 修改时间：23:41:25" itemprop="dateCreated datePublished" datetime="2022-08-15T23:32:02+08:00">2022-08-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今日刷题，居然被这破玩意儿难住了，搞了半个多小时弄了个神必算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">3</span>][<span class="number">128</span>];</span><br><span class="line">    <span class="type">float</span> row[<span class="number">3</span>];</span><br><span class="line">    <span class="type">float</span> buffer = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buffer);</span><br><span class="line">        <span class="built_in">strcpy</span>(input[i], buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(atof(input[j]) &lt; atof(input[j+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(buffer, input[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">strcpy</span>(input[j+<span class="number">1</span>], input[j]);</span><br><span class="line">                <span class="built_in">strcpy</span>(input[j], buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    putc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说出来你可能不信，我当时甚至想拿union来搞位操作判断是几位小数。</p>
<p>后来发现只要用%g就可以忽略浮点数多余的0不输出了。</p>
<p>使用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>,<span class="number">114.51400f</span>);  <span class="comment">//output: 114.514</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%g&quot;</span>,<span class="number">114.51400f</span>);</span><br><span class="line"><span class="built_in">puts</span>(buffer);               <span class="comment">//output: 114.514</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/%E5%9C%A8vscode%E4%B8%8A%E6%90%AD%E5%BB%BAWSL2%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%9C%A8vscode%E4%B8%8A%E6%90%AD%E5%BB%BAWSL2%E4%B8%8B%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">在vscode上搭建WSL2下的C语言开发环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-15 21:02:39" itemprop="dateCreated datePublished" datetime="2022-08-15T21:02:39+08:00">2022-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 23:31:00" itemprop="dateModified" datetime="2022-08-18T23:31:00+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于Visua Studio仅有C++编译器，且其对C标准库改动过大，我的C程序开发主要在WSL2上进行。<br>这篇文档将会引导你在Windows10&#x2F;11上使用vscode连接本地WSL2进行Linux环境下的C程序开发。<br>如果你尚未部署WSL2，请翻阅<a href="https://iaksh.github.io/2022/08/11/WSL2%E4%B8%8EWSLg%E7%9A%84%E9%83%A8%E7%BD%B2/">这篇文章</a></p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>我没有使用微软官方的C&#x2F;C++插件，因为它从某种角度来说太糟糕了。<br>这也意味着这套开发环境能够在vscodium上正常部署。</p>
<h1 id="我选用的技术栈"><a href="#我选用的技术栈" class="headerlink" title="我选用的技术栈"></a>我选用的技术栈</h1><table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>文本编辑器</td>
<td>Visual Studio Code</td>
</tr>
<tr>
<td>编译器</td>
<td>gcc</td>
</tr>
<tr>
<td>调试器</td>
<td>gdb</td>
</tr>
<tr>
<td>构建工具</td>
<td>CMake + Makefile（可替换为Ninja）</td>
</tr>
<tr>
<td>代码补全</td>
<td>clangd</td>
</tr>
<tr>
<td>代码格式化</td>
<td>clang-format</td>
</tr>
</tbody></table>
<p><em>（其实你也可以选用全套LLVM&#x2F;Clang工具链，但依然无法摆脱gcc）</em></p>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="在Windows上为vscode安装插件"><a href="#在Windows上为vscode安装插件" class="headerlink" title="在Windows上为vscode安装插件"></a>在Windows上为vscode安装插件</h2><p><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl">Remote - WSL</a></p>
<h2 id="在WSL2上安装C工具链"><a href="#在WSL2上安装C工具链" class="headerlink" title="在WSL2上安装C工具链"></a>在WSL2上安装C工具链</h2><ol>
<li><p>安装gcc工具链以及CMake，git<br><em>（部分发行版的部分安装策略中是包含了这一工具链的，若有，无视这条。）</em><br>Debian系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc gdb make cmake git</span><br></pre></td></tr></table></figure>
<p>Redhat系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc gdb make cmake git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装cland和clang-format<br>注：这一步实际上<strong>会安装LLVM&#x2F;Clang工具链</strong><br>Debian系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clangd clang-format</span><br></pre></td></tr></table></figure>
<p>Redhat系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-tools-extra</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用vscode在WSL2中安装插件"><a href="#使用vscode在WSL2中安装插件" class="headerlink" title="使用vscode在WSL2中安装插件"></a>使用vscode在WSL2中安装插件</h2><p>在Windows上使用vscode的Remote - WSL插件连接到WSL2后，安装以下插件至WSL2：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=coolchyni.beyond-debug">GDB Debugger - Beyond</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=twxs.cmake">CMake</a></li>
<li><a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools</a></li>
</ol>
<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><ol>
<li><p>快速创建一个CMake项目：<br>连接到WSL2后按ctrl+shift+p，在弹出的输入框中输入CMake: Quick Start然后回车。<br>期间需要选择项目类型（库or可执行），项目名称，以及编译工具链。</p>
</li>
<li><p>调用clang-tidy：<br>clang-format的功能被集成到了clangd插件中，在编辑器中右键选择格式化文档即可。</p>
</li>
<li><p>Debug：<br>打断点之类的操作流程没有变化，但是在开始Debug之前，你需要手动指定可执行文件路径。<br>除非CMakeLists.txt里指定了别的构建位置，可执行文件一般会生成在项目的build&#x2F;目录中。<br>第一次运行Debug时，请点击vscode左侧的“运行和调试”选项卡，点击“创建 launch.json文件”，调试器选择“GDB(Beyond)”。<br>将”program”键的值该为你的可执行文件路径，即可正常Debug。<br>另：你可以使用${workspaceRoot}（vscode提供的宏）来匹配路径，以保证项目文件的可移植性。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/15/%E5%AF%B9%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA%E7%9A%84%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/%E5%AF%B9%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA%E7%9A%84%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">对笔记本混合输出的探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 01:00:36 / 修改时间：01:24:11" itemprop="dateCreated datePublished" datetime="2022-08-15T01:00:36+08:00">2022-08-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  这篇文章并没有写完，有待更新。</p>
<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>  几日前购置了一台游戏本，却无心拿它去玩什么游戏了。<br>  但又碍于发热过高，于是想到开启混合输出是否能在日常使用中平衡GPU负载，降低功耗。</p>
<h1 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h1><p>  考虑到某些可能存在的隐患，我不想直接写出笔记本型号，这里列出其大致参数。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>参数</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>Intel Core i7 12700H</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>GPU0</td>
<td>Iris XE</td>
<td>96eu</td>
</tr>
<tr>
<td>GPU1</td>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>140W</td>
</tr>
<tr>
<td>电源适配器</td>
<td>230W</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<h1 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h1><p>  使用Windows 11 “电影和电视”程序播放 SONY DEMO 4K 演示片 ( 2160 X 3840 60fps )<br>  其他的，我暂时懒得弄了，下次继续。</p>
<h1 id="功耗检测软件"><a href="#功耗检测软件" class="headerlink" title="功耗检测软件"></a>功耗检测软件</h1><p>  使用HWMonitor(x64)监控CPU GT Power。<br>  使用Nvidia Experience监控RTX 3060 Laptop功耗。</p>
<h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>  混合输出：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>最大功耗</th>
<th>平均功耗</th>
<th>平均使用率</th>
</tr>
</thead>
<tbody><tr>
<td>CPU Powers</td>
<td>20.36W</td>
<td>10.5W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>CPU GT Powers</td>
<td>3.35W</td>
<td>1.5W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Iris XE (96EU)</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>50%</td>
</tr>
<tr>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>N&#x2F;A</td>
<td>N&#x2F;A</td>
<td>0%</td>
</tr>
</tbody></table>
<p>  独显直连</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>最大功耗</th>
<th>平均功耗</th>
<th>平均使用率</th>
</tr>
</thead>
<tbody><tr>
<td>CPU Powers</td>
<td>20.18W</td>
<td>7.3W</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>Nvidia GeForce RTX 3060 Laptop</td>
<td>24W</td>
<td>21W</td>
<td>38%</td>
</tr>
</tbody></table>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>  在当前实验环境下，混合输出确实能减少观看4k 60fps hdr影片时的功耗，由此类推，在日常使用中，混合输出较独显直连更加省电，<em>理论上</em>能减少发热。<br>  但当前测试环境中独显为使用三星8nm工艺的RTX 3060 Laptop，考虑到三星工艺糟糕的能效表现，<strong>此次实验结果在Nvidia 20&#x2F;10系显卡上的不一定适用</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/14/%E5%85%B3%E4%BA%8Estring-h%E7%9A%84%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/14/%E5%85%B3%E4%BA%8Estring-h%E7%9A%84%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">关于string.h的笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-14 22:13:43" itemprop="dateCreated datePublished" datetime="2022-08-14T22:13:43+08:00">2022-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-15 01:23:26" itemprop="dateModified" datetime="2022-08-15T01:23:26+08:00">2022-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  近日在LeetCode上刷题，发现string.h内容忘差不多了，随手记一记（指复制粘贴）</p>
<h1 id="string-h定义的类型"><a href="#string-h定义的类型" class="headerlink" title="string.h定义的类型"></a>string.h定义的类型</h1><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p>  其实就是个无符号整数（具体类型与编译器实现相关）。同时也是sizeof关键字所返回的类型。</p>
<h1 id="string-h定义的宏"><a href="#string-h定义的宏" class="headerlink" title="string.h定义的宏"></a>string.h定义的宏</h1><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>  不用再解释了吧。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="string-h定义的函数"><a href="#string-h定义的函数" class="headerlink" title="string.h定义的函数"></a>string.h定义的函数</h1><h2 id="mem系"><a href="#mem系" class="headerlink" title="mem系"></a>mem系</h2><h3 id="memchr"><a href="#memchr" class="headerlink" title="memchr"></a>memchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str 所指向的内存中前 n 个字节里第一次出现的（无符号）字符 c 的指针。</p>
<hr>
<h3 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  比较从 str1 开始的 n 个字节与从 str2 开始的 n 个字节。<br>  <em>(cmp -&gt; compare)</em></p>
<hr>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将以 src 为起点的 n 个字节复制到以 dest 为起点的 n 个字节。</p>
<hr>
<h3 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  类似memcpy，但更安全。</p>
<blockquote>
<p>如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。(来源：<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-memmove.html">菜鸟教程</a>)</p>
</blockquote>
<hr>
<h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  设置以 str 为起点，位移 +n 的地址的值为 c。</p>
<hr>
<h2 id="str系"><a href="#str系" class="headerlink" title="str系"></a>str系</h2><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure>
<p>  把src所指向的字符串接到dest所指向的字符串的末尾。<br>  返回一个指向最终的目标字符串 dest 的指针</p>
<hr>
<h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat"></a>strncat</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将 scr 所指向的字符串的前 n 个字符复制到 dest 所指向的字符串的末尾。</p>
<hr>
<h3 id="strchr"><a href="#strchr" class="headerlink" title="strchr"></a>strchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>
<p>  搜索 str 所指向的字符串中第一次出现的（无符号）字符 c 并返回其指针。</p>
<hr>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  比较 str1 ， str2 两者所指向的字符串的内容。</p>
<hr>
<h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp"></a>strncmp</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  比较 str1 ， str2 两者所指向的字符串的内容，但只比较前 n 个字符。</p>
<hr>
<h3 id="strcoll"><a href="#strcoll" class="headerlink" title="strcoll"></a>strcoll</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  与Localization support有关，暂时无法理解。</p>
<blockquote>
<p>把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。</p>
</blockquote>
<hr>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure>
<p>  将 src 所指向的字符串复制到 dest。</p>
<hr>
<h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy"></a>strncpy</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  将 src 所指向的字符串复制到 dest，但只复制前 n 个字符。</p>
<hr>
<h3 id="strcspn"><a href="#strcspn" class="headerlink" title="strcspn"></a>strcspn</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str1 中第几个字符与 str2 的某一个字符相同。</p>
<h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror"></a>strerror</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span></span><br></pre></td></tr></table></figure>
<p>  起初我不太理解，但看到这行：</p>
<blockquote>
<p>C 库函数 char *strerror(int errnum) 从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。strerror 生成的错误字符串取决于开发平台和编译器。（<a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-strerror.html">菜鸟教程</a>)</p>
</blockquote>
<p>  似乎是配合errno.h获取最近的报错描述字符串的。<br>  使用列如下。<br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      FILE *fp;</span><br><span class="line">      fp = fopen(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>( fp == <span class="literal">NULL</span> ) </span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Error: No such file or directory</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br></pre></td></tr></table></figure>
<p>  返回 str 所指向的字符串的长度（直到但不包括\0）。</p>
<hr>
<h3 id="strpbrk"><a href="#strpbrk" class="headerlink" title="strpbrk"></a>strpbrk</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。</p>
</blockquote>
<hr>
<h3 id="strrchr"><a href="#strrchr" class="headerlink" title="strrchr"></a>strrchr</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在参数 str 所指向的字符串中搜索<strong>最后一次</strong>出现字符 c（一个无符号字符）的位置。</p>
</blockquote>
<hr>
<h3 id="strspn"><a href="#strspn" class="headerlink" title="strspn"></a>strspn</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</p>
</blockquote>
<hr>
<h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a>strstr</h3><p>  <del>所以这是什么鬼名字</del><br>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。</p>
</blockquote>
<hr>
<h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分解字符串 str 为一组字符串，delim 为分隔符。</p>
</blockquote>
<hr>
<h3 id="strxfrm"><a href="#strxfrm" class="headerlink" title="strxfrm"></a>strxfrm</h3>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strxfrm</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>
<p>  也与Localization support有关，还是无法理解。</p>
<blockquote>
<p>根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。</p>
</blockquote>
<h1 id="末"><a href="#末" class="headerlink" title="末"></a>末</h1><p>  string.h中同时包括了memxxx和strxxx函数，很明显，这是因为char既是byte。一般来说，char的二进制占8位，共计1字节。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html">菜鸟教程 : C 标准库 - &lt;string.h&gt;</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/chapter/10305">腾讯云开发者社区开发者手册 : 本地化支持 | Localization support</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/13/%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E7%AE%A1%E7%90%86%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8tar%E7%AE%A1%E7%90%86%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">在Linux中使用tar管理归档文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-13 11:37:01 / 修改时间：13:00:27" itemprop="dateCreated datePublished" datetime="2022-08-13T11:37:01+08:00">2022-08-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  近来我在云服务器上搭建潜渊症的游戏服务器，时常需要从本地打包文件上传以及从云端打包然后传回文件。<br>  我发现.zip虽然在Windows以及Linux上都通用，但却无法保留文件属性，相较之下，在Linux上，使用tar将文件打包为.tar.gz进行归档是个更好的选择。</p>
<h1 id="什么是tar命令"><a href="#什么是tar命令" class="headerlink" title="什么是tar命令"></a>什么是tar命令</h1><p>  tar命令（英文全拼：tape archive ），用于备份文件。<br>  tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。</p>
<h1 id="最常用的三组tar命令"><a href="#最常用的三组tar命令" class="headerlink" title="最常用的三组tar命令"></a>最常用的三组tar命令</h1><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.tar.gz a.c   //压缩 a.c文件为test.tar.gz</span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>–create</td>
<td>建立新的备份文件</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h2 id="列出压缩文件的内容"><a href="#列出压缩文件的内容" class="headerlink" title="列出压缩文件的内容"></a>列出压缩文件的内容</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -tzvf test.tar.gz </span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-t</td>
<td>–list</td>
<td>列出备份文件的内容</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf test.tar.gz </span><br></pre></td></tr></table></figure>
<p>  参数解释：</p>
<table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-x</td>
<td>–extract或–get</td>
<td>从备份文件中还原文件</td>
</tr>
<tr>
<td>-z</td>
<td>–gzip或–ungzip</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-f xxx</td>
<td>–file&#x3D;xxx</td>
<td>指定备份文件</td>
</tr>
</tbody></table>
<h1 id="其他一些可能有用的参数（部分）"><a href="#其他一些可能有用的参数（部分）" class="headerlink" title="其他一些可能有用的参数（部分）"></a>其他一些可能有用的参数（部分）</h1><table>
<thead>
<tr>
<th>短参</th>
<th>长参</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-A</td>
<td>–catenate</td>
<td>新增文件到已存在的备份文件</td>
</tr>
<tr>
<td>-d</td>
<td>–diff或–compare</td>
<td>对比备份文件内和文件系统上的文件的差异</td>
</tr>
<tr>
<td>-k</td>
<td>–keep-old-files</td>
<td>解开备份文件时，不覆盖已有的文件</td>
</tr>
<tr>
<td>-m</td>
<td>–modification-time</td>
<td>还原文件时，不变更文件的更改时间</td>
</tr>
<tr>
<td>-N&lt;日期格式&gt;</td>
<td>–newer&#x3D;&lt;日期时间&gt;</td>
<td>只将较指定日期更新的文件保存到备份文件里</td>
</tr>
<tr>
<td>-O</td>
<td>–stdout</td>
<td>把从备份文件里还原的文件输出到标准输出设备</td>
</tr>
<tr>
<td>-p</td>
<td>–same-permissions</td>
<td>用原来的文件权限还原文件</td>
</tr>
<tr>
<td>-r</td>
<td>–append</td>
<td>新增文件到已存在的备份文件的结尾部分</td>
</tr>
<tr>
<td>-u</td>
<td>–update</td>
<td>仅置换较备份文件内的文件更新的文件</td>
</tr>
<tr>
<td>N&#x2F;A</td>
<td>–ignore-failed-read</td>
<td>忽略数据读取错误，不中断程序的执行</td>
</tr>
</tbody></table>
<h1 id="我的一些感想"><a href="#我的一些感想" class="headerlink" title="我的一些感想"></a>我的一些感想</h1><p>不只是tar，Linux上的很多工具都给我一种感觉。在Windows上需要某个第三方软件来完成的事，对Linux上的工具而言只是它们最基础的功能。Linux上的这些工具能很方便的嵌入自动化脚本中，整个系统就像是一个巨大的程序库，共给shell调用。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-tar.html">菜鸟教程-Linux tar 命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://iaksh.github.io/2022/08/12/Dev-C-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IAKSH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello world!">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/12/Dev-C-%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Dev-C++的安装和使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-12 15:45:16" itemprop="dateCreated datePublished" datetime="2022-08-12T15:45:16+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-14 22:59:49" itemprop="dateModified" datetime="2022-08-14T22:59:49+08:00">2022-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>  其实，我有软件洁癖。但是学校好像要求要用Dev-C++，所以我在虚拟机里进行了配置，并写下了这篇博文。<br>  <del>（后日谈：后来我发现Dev-C++还是有几分优雅的，于是迅速在物理机上整了个）</del><br>  我对Dev-C++这样老掉牙且有先天缺陷的IDE一向是嗤之以鼻的，但看了一些文章以后，这样的看法似乎有一些改观了。<br>  Dev-C++也许不是一个趁手的工具，但它不失为一个合适的教具。</p>
<h1 id="什么是Dev-C"><a href="#什么是Dev-C" class="headerlink" title="什么是Dev-C++"></a>什么是Dev-C++</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>  Dev-C++是以Delphi编写（存疑）的，运行在Windows上的，以MinGW-W64（或TDM-GCC）为后端的<strong>基于GPL协议开源</strong>的C&#x2F;C++集成开发环境（IDE）<br>  Dev-C++功能简陋…不，应该是某种意义上的简洁，对新人不太友好但却实际上适合新手入门以及充当C&#x2F;C++的教学工具。</p>
<h2 id="Dev-C-的各个分支"><a href="#Dev-C-的各个分支" class="headerlink" title="Dev-C++的各个分支"></a>Dev-C++的各个分支</h2><p>  Dev-C++，作为一个开源项目，它也有着在大多数开源项目上常见的悲惨，却又幸运的命运。<br>  2000年左右，Bloodshed Software团队以构建一个轻量，免费，开源的C&#x2F;C++ IDE为宗旨，创建了Dev-C++项目。不过由于整个团队几乎是在用爱发电，到2005年时，Bloodshed以“失去开发动力”为由，宣布无限期暂停Dev-C++的更新，Dev-C++的版本号停滞在了4.9.9。<br>  但是当时的Dev-C++实在是太讨人喜欢了，在原团队停止开发后，无数的社区开发者们自发地扛起了Dev-C++的更新工作，其中最有名的当属Orwell团队。<br>  Orwell团队在2011年成功将Dev-C++的版本号推至5.x，在2016年发布了他们的最后一个版本——5.11。<br>  从2016年到2020年，只有一些个人维护的Dev-C++分支仍在更新，Dev-C++社区总体上停滞不前。<br>  但2020年7月，Embarcadero公司投入资金并以Orwell Dev-C++ 5.11为蓝本继续开发，这也就是我们即将接触的Embarcadero Dev-C++的来源。</p>
<h2 id="我为什么认为Dev-C-是一个好的C语言教具"><a href="#我为什么认为Dev-C-是一个好的C语言教具" class="headerlink" title="我为什么认为Dev-C++是一个好的C语言教具"></a>我为什么认为Dev-C++是一个好的C语言教具</h2><p>  众所周知，完事开头难，如果你让一个从未学习过编程的人一来就使用Visual Studio这样的工具，它多半还没有开始敲字就被一堆又一堆的按钮给吓住了。<br>  使用Dev-C++这样老旧的IDE有一个好处，就是它并不会像Visua Studio那样将编译链接的过程隐藏起来，也没有IntelliCode来掩盖你记不住关键字和函数的事实。Dev-C++将编译链接的理论模型简单套上一层自动化脚本，然后直接摆在使用者的面前，给人一种好像就是在用终端指令操纵gcc去编译程序的感觉，熟悉Dev-C++的操作流程以后，能较为方便地切换到Makefile以及CMake这样更加专业的构建工具上，我想这也是老一辈程序员们热爱它的原因，某种意义上它难以理解，某种意义上它也简单干净，它不为资本所追求的快速迭代而服务，它忠于技术本身，它属于程序员。</p>
<h1 id="Dev-C-的下载与安装"><a href="#Dev-C-的下载与安装" class="headerlink" title="Dev-C++的下载与安装"></a>Dev-C++的下载与安装</h1><h2 id="下载Dev-C-安装包"><a href="#下载Dev-C-安装包" class="headerlink" title="下载Dev-C++安装包"></a>下载Dev-C++安装包</h2><p>  作为名副其实的老开源项目，Orwell Dev-C++的仓库托管在<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/orwelldevcpp/">Sourceforge</a>，而重生于2020年的Embarcadero Dev-C++则开源于<a target="_blank" rel="noopener" href="https://github.com/Embarcadero/Dev-Cpp">Github</a><br>  你可以在上述Github仓库页面找到Embarcadero Dev-C++的最新Release。截至本文完稿时的最新版本为6.3，附带的编译器为TDM-GCC，这也是下面我用到的版本。</p>
<h2 id="安装Dev-C"><a href="#安装Dev-C" class="headerlink" title="安装Dev-C++"></a>安装Dev-C++</h2><p>  <del>你不会拿到安装包了还不会装吧？</del><br>  <del>不会吧不会吧？</del><br>  Embarcadero Dev-C++的Github Release里应该同时包含了exe安装包和可绿色安装的压缩包，我的建议是使用后者，解压即用，双击devcpp.exe起飞。<br>  第一次启动Dev-C++时会要你选择语言和一些主题设置，我的建议是使用Visual Studio Dark配色以及Windows10图标，不包你喜欢但是保证不辣眼睛。</p>
<h1 id="Dev-C-的基本操作"><a href="#Dev-C-的基本操作" class="headerlink" title="Dev-C++的基本操作"></a>Dev-C++的基本操作</h1><h2 id="新建和打开一个工程"><a href="#新建和打开一个工程" class="headerlink" title="新建和打开一个工程"></a>新建和打开一个工程</h2><p>  和大多数IDE一样，在开始编码之前你得先创建一个项目，进入软件后点击左上角文件-&gt;新建-&gt;项目，然后选择你要创建的项目类型。<br>  这里我以控制台程序（Console Application）为例。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYYOKO"><img src="https://s1.ax1x.com/2022/08/12/vYYOKO.png" alt="vYYOKO.png"></a><br>  点击确认后会需要你选择一个位置作为该项目的根目录，随后会在你选择的路径下创建一个项目文件，如下图。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYt3sU"><img src="https://s1.ax1x.com/2022/08/12/vYt3sU.png" alt="vYt3sU.png"></a><br>  这实际上是一个文本文件，它记录了该项目的各种配置以及源文件路径，你可以使用任意文本编辑器来查看它的内容，比如我的：<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYtUiR"><img src="https://s1.ax1x.com/2022/08/12/vYtUiR.png" alt="vYtUiR.png"></a><br>  当你关闭Dev-C++后，只需要用Dev-C++打开该.dev文件即可再次打开该工程。<br>  最简单的操作流程就是把.dev文件拖到devcpp.exe上，就像这样…<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYtTeg"><img src="https://s1.ax1x.com/2022/08/12/vYtTeg.png" alt="vYtTeg.png"></a></p>
<h2 id="向工程中添加源文件和头文件"><a href="#向工程中添加源文件和头文件" class="headerlink" title="向工程中添加源文件和头文件"></a>向工程中添加源文件和头文件</h2><p>  你可以直接右键某个项目然后新建一个文本文件在里面<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYN0ts"><img src="https://s1.ax1x.com/2022/08/12/vYN0ts.png" alt="vYN0ts.png"></a><br>  新建文件的路径，名称还有后缀都由你自己决定，Dev-C++和后面的编译器都只靠文件后缀来判断是源文件还是头文件或者是其他的什么玩意儿。但关于路径我想说的是，Dev-C++甚至允许你把添加的文件丢在任何一个目录，但我建议不要把他们丢在项目的根目录外面。</p>
<p>  你还可以右键工程以后直接点击“New File”，和上面的差不多，但是你得先按Ctrl+S保存才能选择保存路径。<br>  你也许也注意到了，工程的右键菜单里有创建文件夹，我想说的是这个“文件夹”并不是实际文件结构中的文件夹，只是在Dev-C++中对源文件和头文件进行分组归类。</p>
<h1 id="编译你的工程"><a href="#编译你的工程" class="headerlink" title="编译你的工程"></a>编译你的工程</h1><p>  在项目下放列出的所有文件都会被加入到Dev-C++的构建系统中，此时点击运行选项卡中的编译选项即可。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYdpm8"><img src="https://s1.ax1x.com/2022/08/12/vYdpm8.png" alt="vYdpm8.png"></a></p>
<h1 id="运行你的工程"><a href="#运行你的工程" class="headerlink" title="运行你的工程"></a>运行你的工程</h1><p>  再去看看上面所说的那个选项卡，你会发现里面有“运行”和“编译运行”这两个选项。<br>  和Visual Studio不一样，Dev-C++的“运行”就真的只是运行，不包含编译。<br>  也就是说，在运行之前，你得先把你的程序编译出来。（这一点同样适用于很多老旧的IDE，比如隔壁Code::Blocks）<br>  至于“编译运行”这个选项，其实就是字面意思，把两步合并在了一起，也就是一键开跑了，倒也还算方便。</p>
<h1 id="在Dev-C-中Debug"><a href="#在Dev-C-中Debug" class="headerlink" title="在Dev-C++中Debug"></a>在Dev-C++中Debug</h1><p>  Dev-C++的Debug功能实际上是调用gdb实现的，使用流程也无非就是常见的打断点-&gt;Debug运行，然后步进啥的，看一眼你们大概就都会了。<br>  对了，Dev-C++的断点是不会独立成一行的，而是和行号重叠，在编辑器里点一下行号就能打断点了。<br>  另外，开始Debug的按钮是“运行”选项卡里的“调试”，如下图所示。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYBnnP"><img src="https://s1.ax1x.com/2022/08/12/vYBnnP.png" alt="vYBnnP.png"></a></p>
<h1 id="使用快捷键替代鼠标操纵"><a href="#使用快捷键替代鼠标操纵" class="headerlink" title="使用快捷键替代鼠标操纵"></a>使用快捷键替代鼠标操纵</h1><p>  说句大实话，这是提升你的生产效率的必要途径。在各个选项卡中你可以在找到各个功能对应的快捷键（写在右侧，比如调试的快捷键是F5），熟练后尽量使用那些快捷键，而不是慢吞吞地摸出鼠标然后到处点点点。</p>
<h1 id="Dev-C-其他的一些功能"><a href="#Dev-C-其他的一些功能" class="headerlink" title="Dev-C++其他的一些功能"></a>Dev-C++其他的一些功能</h1><h2 id="代码格式化工具"><a href="#代码格式化工具" class="headerlink" title="代码格式化工具"></a>代码格式化工具</h2><p>  Dev-C++集成了AStyle，可以快速按照某种代码风格来格式化你的代码。<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYDG5D"><img src="https://s1.ax1x.com/2022/08/12/vYDG5D.png" alt="vYDG5D.png"></a><br>  具体的格式化策略你可以点击“格式化选项”来修改。<br>  顺便一提：<br>  <a target="_blank" rel="noopener" href="https://imgtu.com/i/vYDxZ6"><img src="https://s1.ax1x.com/2022/08/12/vYDxZ6.png" alt="vYDxZ6.png"></a><br>  好吧，只是抖个机灵。<br>  实际上我也并没有完全遵守Allman风格。</p>
<h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>  在“工具”选项卡里你可以找到“编译选项”，值得一提的是这里将编译指令和链接指令分开了。<br>  至于这里应该写些什么，你可能得先去了解一下gcc和ld，以后我可能会写一文介绍它们。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>  至此，你应该以及能够使用Dev-C++进行基本的开发和调试了，剩下的就是学习C&#x2F;C++这两门语言本身，以及它们的生态了。<br>  作为（半个）过来人，相信我，在C++面前，起初你可能心情激动，满脑子“就这？”，但越是学到后面，你会愈发地痛不欲生。</p>
<h1 id="附：Dev-C-构建系统的实质"><a href="#附：Dev-C-构建系统的实质" class="headerlink" title="附：Dev-C++构建系统的实质"></a>附：Dev-C++构建系统的实质</h1><p>  其实如果你去看一眼创建的工程的目录就会发现，Dev-C++其实是调用的Makefile进行的项目构建。<br>  具体的Makefile脚本就是项目根目录下的“Makefile.win”。<br>  至于Makefile是什么以及有什么用，那就说来话长了，等我以后再写一文吧。<br>  但是要简单说说也行，Makefile提供了一套简单的系统来按需编译源文件然后链接，主要解决的就是编译问题，Makefile只会重新编译那些被修改了的源文件，而保留其他没有被修改的源文件的目标文件，大大减少了大型项目中重复的不必要编译，提高了项目整体的编译速度。<br>  当然Makefile也可以玩得很花，远远不止上述内容，不过那些就真的是另一文的内容了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/408296605/answer/1534214395">知乎：如何评价Embarcadero Dev-C++? - JohnLu的回答</a><br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Dev-C++">百度百科：Dev-C++</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IAKSH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/IAKSH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IAKSH" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:askzrj21@163.com" title="E-Mail → mailto:askzrj21@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IAKSH</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
